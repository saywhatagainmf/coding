---
title: Простые числа
weight: 1
draft: true
---

## Проверка на простоту за $O(\\sqrt{N})$

$N$ - число, для которого мы определяем, простое ли оно.

### Основные понятия

Рекомендуется сначала прочитать статью про [простые
числа](Простое_число "wikilink").

### Проверка на простоту за $O(N)$

Линейная проверка очень простая - надо просто перебрать все числа от $2$
до $N - 1$ и проверить, что $N$ не делится ни на одно из них. Отдельно
обрабатывается случай для $N = 1$.

``` C++
bool isPrime(int n) {
    if (n == 1) {
        return false;
    }
    for (int i = 2; i < n; i++) {
        if (n % i == 0) {
            return false;
        }
    }
    return true;
}
```

### Ускорение до $O(\\sqrt{N})$

Иными словами, если число $N$ равно произведению двух других, то одно из
них не больше корня из $N$, а другое не меньше корня из $N$.

Из этого следует, что если число $N$ не делится ни на одно из чисел $2,
3, 4, \\ldots, \\bigl\\lfloor\\sqrt{N}\\bigr\\rfloor$, то оно не делится
и ни на одно из чисел $\\bigl\\lceil\\sqrt{N}\\bigr\\rceil + 1, \\ldots,
N-2, N-1$, так как если есть делитель больше корня (не равный $N$), то
есть делитель и меньше корня (не равный $1$). Поэтому в цикле `for`
достаточно проверять числа не до $N$, а до корня.

``` C++
bool isPrime(int n) {
    if (n == 1) {
        return false;
    }
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            return false;
        }
    }
    return true;
}
```

## Нужная теория

Возьмём любое простое число $p$. Пусть $p - 1 = 2^n \\cdot m$, где $m$ —
нечётно.

Тогда заметим, что если есть какое-то число $x$, для которого не
выполнено описанное утверждение, то значит $p$ точно не простое.
Число $x$ называется **свидетелем простоты числа $p$**, если для него
выполнено описанное выше утверждение (при этом $p$ в этом случае не
обязательно простое).

Так как $\\varphi(n) \< n$, то если взять случайное число $a$, то оно с
вероятностью меньше $1/4$ будет свидетелем простоты числа $p$.

## Алгоритм

Пусть есть число $p$, которое мы хотим проверить на простоту. Тогда
проверка того, что $p - 1$ делится на $2$ работает за $O(\\log p)$
(длина числа $p$). Так как максимальная степень 2, на которую делится $p
- 1$ это $\\log p$, то за $O(\\log^2 p)$ можно представить $p - 1 = 2^n
\\cdot m$.

Далее можно взять случайное число $a$ от $1$ до $p$. С помощью [быстрого
возведения в степень](Бинарное_возведение_в_степень "wikilink") можно
посчитать $a^m$ по модулю $p$. Так как числа имеют длину $O(\\log
p)$, и умножение двух чисел работает за $O(\\log^2 p)$, а значит быстрое
возведение в степень работает за $O(\\log^3 p)$. Так мы посчитали $a^m$
по модулю $p$. Если число сравнимо с -1 или 1, то $a$ — свидетель
простоты. Если же нет, то $n$ раз возводим число в квадрат и
проверяем, что не сравнимо ли оно с $-1$ по модулю $p$. Итого за
$O(\\log^3 n)$ можно проверить число на свидетеля простоты.

Дальше чем более точная вероятность того, что $p$ составное вам нужна,
тем больше раз вам надо повторить тест. При этом если повторить тест
$k$ раз и каждое число свидетель простоты, то число составное с
вероятностью $1/2^{2k}$. Итого время работы $O(k\\cdot\\log^3
n)$.
