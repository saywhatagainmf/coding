---
title: Окружности
weight: 5
draft: true
---

Пересечение окружности и прямой
Дана окружность (координатами своего центра и радиусом) и прямая (своим уравнением). Требуется найти точки их пересечения (одна, две, либо ни одной).

Решение
Вместо формального решения системы двух уравнений подойдём к задаче с геометрической стороны (причём, за счёт этого мы получим более точное решение с точки зрения численной устойчивости).

Предположим, не теряя общности, что центр окружности находится в начале координат (если это не так, то перенесём его туда, исправив соответствующе константу C в уравнении прямой). Т.е. имеем окружность с центром в (0,0) радиуса r и прямую с уравнением Ax + By + C = 0.

Сначала найдём ближайшую к центру точку прямой - точку с некоторыми координатами (x0,y0). Во-первых, эта точка должна находиться на таком расстоянии от начала координат:

    |C|
----------
sqrt(A2+B2)
Во-вторых, поскольку вектор (A,B) перпендикулярен прямой, то координаты этой точки должны быть пропорциональны координатам этого вектора. Учитывая, что расстояние от начала координат до искомой точки нам известно, нам нужно просто нормировать вектор (A,B) к этой длине, и мы получаем:

        A C
x0 = - -----
       A2+B2

        B C
y0 = - -----
       A2+B2
(здесь неочевидны только знаки 'минус', но эти формулы легко проверить подстановкой в уравнение прямой - должен получиться ноль)

Зная ближайшую к центру окружности точку, мы уже можем определить, сколько точек будет содержать ответ, и даже дать ответ, если этих точек 0 или 1.

Действительно, если расстояние от (x0, y0) до начала координат (а его мы уже выразили формулой - см. выше) больше радиуса, то ответ - ноль точек. Если это расстояние равно радиусу, то ответом будет одна точка - (x0,y0). А вот в оставшемся случае точек будет две, и их координаты нам предстоит найти.

Итак, мы знаем, что точка (x0, y0) лежит внутри круга. Искомые точки (ax,ay) и (bx,by), помимо того что должны принадлежать прямой, должны лежать на одном и том же расстоянии d от точки (x0, y0), причём это расстояние легко найти:

                  C2
d = sqrt ( r2 - ----- )
                A2+B2
Заметим, что вектор (-B,A) коллинеарен прямой, а потому искомые точки (ax,ay) и (bx,by) можно получить, прибавив к точке (x0,y0) вектор (-B,A), нормированный к длине d (мы получим одну искомую точку), и вычтя этот же вектор (получим вторую искомую точку).

Окончательное решение такое:

                d2
mult = sqrt ( ----- )
              A2+B2

ax = x0 + B mult
ay = y0 - A mult
bx = x0 - B mult
by = y0 + A mult
Если бы мы решали эту задачу чисто алгебраически, то скорее всего получили бы решение в другом виде, которое даёт бОльшую погрешность. Поэтому "геометрический" метод, описанный здесь, помимо наглядности, ещё и более точен.

Реализация
Как и было указано в начале описания, предполагается, что окружность расположена в начале координат.

Поэтому входные параметры - это радиус окружности и коэффициенты A,B,C уравнения прямой.

double r, a, b, c; // входные данные

double x0 = -a*c/(a*a+b*b),  y0 = -b*c/(a*a+b*b);
if (c*c > r*r*(a*a+b*b)+EPS)
	puts ("no points");
else if (abs (c*c - r*r*(a*a+b*b)) < EPS) {
	puts ("1 point");
	cout << x0 << ' ' << y0 << '\n';
}
else {
	double d = r*r - c*c/(a*a+b*b);
	double mult = sqrt (d / (a*a+b*b));
	double ax,ay,bx,by;
	ax = x0 + b * mult;
	bx = x0 - b * mult;
	ay = y0 - a * mult;
	by = y0 + a * mult;
	puts ("2 points");
	cout << ax << ' ' << ay << '\n' << bx << ' ' << by << '\n';
}

Пересечение двух окружностей
Даны две окружности, каждая определена координатами своего центра и радиусом. Требуется найти все их точки пересечения (либо одна, либо две, либо ни одной точки, либо окружности совпадают).

Решение
Сведём нашу задачу к задаче о Пересечении окружности и прямой.

Предположим, не теряя общности, что центр первой окружности - в начале координат (если это не так, то перенесём центр в начало координат, а при выводе ответа будем обратно прибавлять координаты центра). Тогда мы имеем систему двух уравнений:

x2 + y2 = r12
(x - x2)2 + (y - y2)2 = r22
Вычтем из второго уравнения первое, чтобы избавиться от квадратов переменных:

x2 + y2 = r12
x (-2x2) + y (-2y2) + (x22 + y22 + r12 - r22) = 0
Таким образом, мы свели задачу о пересечении двух окружностей к задаче о пересечении первой окружности и следующей прямой:

Ax + By + C = 0,
A = -2x2,
B = -2y2,
C = x22 + y22 + r12 - r22.
А решение последней задачи описано в соответствующей статье.

Единственный вырожденный случай, который надо рассмотреть отдельно - когда центры окружностей совпадают. Действительно, в этом случае вместо уравнения прямой мы получим уравнение вида 0 = С, где C - некоторое число, и этот случай будет обрабатываться некорректно. Поэтому этот случай нужно рассмотреть отдельно: если радиусы окружностей совпадают, то ответ - бесконечность, иначе - точек пересечения нет.

Нахождение вписанной окружности в выпуклом многоугольнике с помощью тернарного поиска
Дан выпуклый многоугольник с N вершинами. Требуется найти координаты центра и радиус наибольшей вписанной окружности.

Здесь описывается простой метод решения этой задачи с помощью двух тернарных поисков, работающий за O (N log2 C), где C - коэффициент, определяемый величиной координат и требуемой точностью (см. ниже).

Алгоритм
Определим функцию Radius (X, Y), возвращающую радиус вписанной в данный многоугольник окружности с центром в точке (X;Y). Предполагается, что точки X и Y лежат внутри (или на границе) многоугольника. Очевидно, эту функцию легко реализовать с асимптотикой O (N) - просто проходим по всем сторонам многоугольника, считаем для каждой расстояние до центра (причём расстояние можно брать как от прямой до точки, не обязательно рассматривать как отрезок), и возвращаем минимум из найденных расстояний - очевидно, он и будет наибольшим радиусом.

Итак, нам нужно максимизировать эту функцию. Заметим, что, поскольку многоугольник выпуклый, то эта функция будет пригодна для тернарного поиска по обоим аргументам: при фиксированном X0 (разумеется, таком, что прямая X=X0 пересекает многоугольник) функция Radius(X0, Y) как функция одного аргумента Y будет сначала возрастать, затем убывать (опять же, мы рассматриваем только такие Y, что точка (X0, Y) принадлежит многоугольнику). Более того, функция max (по Y) { Radius (X, Y) } как функция одного аргумента X будет сначала возрастать, затем убывать. Эти свойства ясны из геометрических соображений.

Таким образом, нам нужно сделать два тернарных поиска: по X и внутри него по Y, максимизируя значение функции Radius. Единственный особый момент - нужно правильно выбирать границы тернарных поисков, поскольку вычисление функции Radius за пределами многоугольника будет некорректным. Для поиска по X никаких сложностей нет, просто выбираем абсциссу самой левой и самой правой точки. Для поиска по Y находим те отрезки многоугольника, в которые попадает текущий X, и находим ординаты точек этих отрезков при абсциссе X (вертикальные отрезки не рассматриваем).

Осталось оценить асимптотику. Пусть максимальное значение, которое могут принимать координаты - это C1, а требуемая точность - порядка 10-C2, и пусть C = C1 + C2. Тогда количество шагов, которые должен будет совершить каждый тернарный поиск, есть величина O (log C), и итоговая асимптотика получается: O (N log2 C).

Реализация
Константа steps определяет количество шагов обоих тернарных поисков.

В реализации стоит отметить, что для каждой стороны сразу предпосчитываются коэффициенты в уравнении прямой, и сразу же нормализуются (делятся на sqrt(A2+B2)), чтобы избежать лишних операций внутри тернарного поиска.

const double EPS = 1E-9;
int steps = 60;

struct pt {
	double x, y;
};

struct line {
	double a, b, c;
};

double dist (double x, double y, line & l) {
	return abs (x * l.a + y * l.b + l.c);
}

double radius (double x, double y, vector<line> & l) {
	int n = (int) l.size();
	double res = INF;
	for (int i=0; i<n; ++i)
		res = min (res, dist (x, y, l[i]));
	return res;
}

double y_radius (double x, vector<pt> & a, vector<line> & l) {
	int n = (int) a.size();
	double ly = INF,  ry = -INF;
	for (int i=0; i<n; ++i) {
		int x1 = a[i].x,  x2 = a[(i+1)%n].x,  y1 = a[i].y,  y2 = a[(i+1)%n].y;
		if (x1 == x2)  continue;
		if (x1 > x2)  swap (x1, x2),  swap (y1, y2);
		if (x1 <= x+EPS && x-EPS <= x2) {
			double y = y1 + (x - x1) * (y2 - y1) / (x2 - x1);
			ly = min (ly, y);
			ry = max (ry, y);
		}
	}
	for (int sy=0; sy<steps; ++sy) {
		double diff = (ry - ly) / 3;
		double y1 = ly + diff,  y2 = ry - diff;
		double f1 = radius (x, y1, l),  f2 = radius (x, y2, l);
		if (f1 < f2)
			ly = y1;
		else
			ry = y2;
	}
	return radius (x, ly, l);
}

int main() {

	int n;
	vector<pt> a (n);
	... чтение a ...

	vector<line> l (n);
	for (int i=0; i<n; ++i) {
		l[i].a = a[i].y - a[(i+1)%n].y;
		l[i].b = a[(i+1)%n].x - a[i].x;
		double sq = sqrt (l[i].a*l[i].a + l[i].b*l[i].b);
		l[i].a /= sq,  l[i].b /= sq;
		l[i].c = - (l[i].a * a[i].x + l[i].b * a[i].y);
	}

	double lx = INF,  rx = -INF;
	for (int i=0; i<n; ++i) {
		lx = min (lx, a[i].x);
		rx = max (rx, a[i].x);
	}

	for (int sx=0; sx<stepsx; ++sx) {
		double diff = (rx - lx) / 3;
		double x1 = lx + diff,  x2 = rx - diff;
		double f1 = y_radius (x1, a, l),  f2 = y_radius (x2, a, l);
		if (f1 < f2)
			lx = x1;
		else
			rx = x2;
	}

	double ans = y_radius (lx, a, l);
	printf ("%.7lf", ans);

}



## Как задать окружность?

Центром и радиусом.

## Пересечение окружности с прямой

Возможны следующие случаи:

  - Окружность $\\omega$ и прямая $L$ не пересекаются $\\iff$
    [расстояние от центра
    окружности](Прямые#Расстояние_от_точки_до_прямой "wikilink")
    $O$ до $L$ строго больше радиуса окружности
  - $\\omega$ и $L$ касаются $\\iff$ $\\rho(O, L) = R(\\omega) = :R$
  - $\\omega$ и $L$ имеют 2 точки пересечения $\\iff \\rho(O, L) \< R$

Научимся искать точки пересечения. Обозначим их $A$ и $B$ (пока мы их не
умеем искать, но нарисовать картинку нам это не мешает). [Опустим
перпендикуляр](Прямые#Проекция_точки_на_прямую "wikilink") из $O$
на $L \~-$ основание перпендикуляра $H$. В $\\Delta AOH \\text{ мы
знаем} |AO| = R, OH = \\rho(O, L) \\implies \\text{ можем найти по
теореме Пифагора } |AH|$. Заметим теперь, что $A$ и $B$ симметричны
относительно $OH$, из чего мы получаем следующий алгоритм нахождения
$A$ и $B$:

1.  Опускаем перпендикуляр $OH$.
2.  Прибавляем к $H$ $\\pm$(направляющий вектор $L$, нормированный и
    приведённый к длине $AH$).

## Пересечение двух окружностей

Возможны следующие варианты взаимного расположения двух окружностей:

1.  Окружности совпадают (тривиально)
2.  Центр $O_2$ одной из окружностей $\\omega_2$ лежит внутри другой
    окружности $\\omega_1$ и
    1.  окружности не пересекаются $\\iff d(=\\rho(O_2O_1)) + R_2 \<
        R_1$
    2.  окружности касаются $\\iff d + R_2 = R_1$
    3.  окружности имеют 2 точки пересечения $\\iff d + R_2 \> R_1$
3.  Центры окружностей не лежат внутри другой окружности и
    1.  окружности не пересекаются $\\iff d \> R_1 + R_2$
    2.  окружности касаются $\\iff d = R_1 + R_2$
    3.  окружности имеют 2 точки пересечения $\\iff d \< R_2 + R_1$

*Все сравнения выше выполняются с точностью до EPS\!*

Все случаи, кроме 2.3 и 3.3 тривиальны. Разберём 3.3:

Пусть точки пересечения окружностей $\~- A$ и $B$. В $\\Delta O_1O_2A$
мы знаем все 3 стороны $\\implies$ можем по теореме косинусов найти
$\\angle O_2O_1A = \\angle O_2O_1B(= :\\alpha)$ по теореме
косинусов. Теперь, чтобы найти точки $A$ и $B$ достаточно
[повернуть](Векторы#Поворот_вектора "wikilink")
$\\overline{(O_1O_2)}$ на углы $\\pm \\alpha$ и привести к длине
$|O_1A|$, а результат прибавить к точке $O_1$.

## Касательные из точки к окружности

Возможны следующие случаи:

1.  Точка $P$ лежит внутри окружности $\\omega \~-$ в этом случае
    касательных не бывает.
2.  $P$ лежит на $\\omega \~-$ в этом случае касательная ровно одна и
    вектор $\\overline{OP}$ нормальный к этой касательной $\\implies$
    мы уже знаем для этой прямой точку и направляющий вектор, так что
    дальше дело [за
    малым](Прямые#Важные_переходы_между_способами_хранения "wikilink").
3.  $P$ лежит вне $\\omega \\implies$ существует 2 касательные из $P$ к
    $\\omega$. Разберём этот случай отдельно.

Обозначим точки касания за $A$ и $B$. Заметим, что в $\\Delta POA$ мы
знаем гипотенузу и катет $\\implies$ можем найти (по теореме
Пифагора) $|PA|$. Но тогда $A$ и $B$ можно получить как точки
пересечения $\\omega$ с окружностью с центром в $P$ и радиусом
$|PA|$. А мы это уже умеем делать.