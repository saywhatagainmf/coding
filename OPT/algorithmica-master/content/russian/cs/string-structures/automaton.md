---
title: Суффиксный автомат
authors:
- Александр Кульков
editors:
- Сергей Слотин
weight: 2
draft: true
---

Если вы не знаете, что такое префиксное дерево или автомат, рекомендуется сначала почитать про Ахо-Корасик.

Рассмотрим задачу:

> Дан текст $T$ и $n$ строк $s_i$, для каждой из которых нужно узнать, встречается ли она в тексте.

Есть два основных подхода к решению этой задачи. Первый: алгоритм Ахо-Корасик, который строит по набору строк автомат, распознающий эти строки в потоке текста. Второй: использование суффиксных структур, под которыми обычно подразумневают суффиксный массив, суффиксный автомат или суффикское дерево.

Данная статья посвящена последним двум из них.

## Наивное решение

Возьмем все суффиксы $T$ и объединим их в бор, в котором каждой подстроке $T$ будет соответствовать ровно одна вершина. С его помощью можно за $O(|T|^2)$ времени на построение и $O(|s_i|)$ времени на запрос узнавать, входит ли $s_i$ в $T$.

Идея дальнейшей оптимизации заключается в убирании «лишних» состояний в этом боре.

От квадратиченой сложности можно избавиться двумя разными способами — ведущими, соответственно, либо к суффиксному автомату, либо к суфффиксному дереву.

**Сжатое суффиксное дерево.** Любой путь от корня в этом боре будет подстрокой $T$, а значит, если из вершины $v$ нет исходящий рёбер, то можно заменить путь на ребро, храня рядом с ним всю строку. Непосредственно хранить строку при этом не обязательно — она есть где-то как подстрока $T$, а значит можно просто хранить пару чисел $[l, r]$, указывающую на её местоположение.

Выясняется, что такая структура данных занимает $O(|T|)$ памяти. Чтобы это понять, нужно оценить количество «развилок» — мест, где путь разъеденяется на два.

Пусть мы бор строли путем добавления суффиксов. Тогда, каждая новая строка совпадала каким-то префиксом с уже имеющейся, а потом отпочковалась и породила новый путь. Получается, что вершин тут не больше, чем строк.

Сжатое суффиксное дерево тоже годится для нашей задачи: только теперь по рёбрам нужно шагать виртуально, просматривая один символ за другим.

Существуют алгоритмы, которые строят сжатое суффиксное дерево эффективно — например, алгортим Укконена. Мы их рассматривать в этой статье не будем и сразу перейдём ко второму методу.

**Суффиксным автоматом** строки $s$ называется *минимальный* (с наименьшим количеством вершин) *детерминированный* (нет двух различных путей, соответствующих одинаковой строке) автомат, принимающий все различные подстроки $s$ и только их. 

Выясняется, что он тоже маленький, и если хранить переходы в `std::map`, то автомат можно построить за $O(n log k)$ времени и $O(n)$ памяти, где $k$ — размер алфавита (обычно $k$ считают константой, и тогда построение происходит вообще за $O(n)$).

Сперва обозначим основные свойства суффиксного автомата и его состояний, затем опишем алгоритм, а затем поймём, как и почему он работает.

Любое состояние $V$ автомата будет принимать некоторый набор строк $T$, причём если отсортировать эти строки по возрастанию длины, то для любой строки $s_i \in T (i < |T|)$ следующая по порядку строка - это $s_{i+1} = cs_i$ для некоторого символа $c$. Исходя из определения суффиксного автомата, для любого префикса исходной строки $S$ существуют несколько состояний, принимающих его суффиксы: состояние $V_1$, принимающее суффиксы длин от 1 до некоторого $k_1$, состояние $V_2$, принимающее суффиксы длин от $k_1+1$ до $k_2$, и т.д. до состояния, принимающего самые длинные суффиксы данного префикса, включая сам префикс. Из каждого состояния $X$, кроме корневого, существует *суффиксная ссылка*: пусть $X$ принимает некоторую строку $p$, тогда суффиксная ссылка из $X$ ведёт в отличное от $X$ состояние, принимающее суффикс $p$ максимальной длины. Также из каждого состояния $X$, кроме корневого, ведёт ещё одна ссылка, мы назовём её *префиксной*: пусть самая длинная принимаемая $X$ строка - это $p$, тогда префиксная ссылка из $X$ указывает на состояние, принимающее префикс $p$ на единицу меньшей длины. 

Теперь можем перейти к **алгоритму построения суффиксного автомата**. 
Наш алгоритм будет "индуктивным": он будет перестраивать автомат, коррекно построенный для строки $s$, получая из него автомат для строки $sc$.

Предположим, что мы построили суффиксный автомат для строки $s$, удовлетворяющий всем требованиям, и теперь добавляем символ $c$. Пусть $X$ - состояние, которое принимало строку $s$ до добавления $c$. Сперва мы обязаны создать новое состояние $U$, так как появилась строка $sc$, которая ранее не входила в $s$. Затем, мы должны добавить переход из $X$ в $U$ по символу $c$ (потому что должно быть состояние, принимающее $sc$). Таким образом, наше новое состояние $U$ теперь принимает некоторый набор суффиксов $sc$. Перейдём по суффиксной ссылке из $X$. Тогда есть два случая:
1. Перехода по $c$ из текущего состояния нет. Тогда мы можем и должны добавить переход по символу $c$, ведущий в $U$: теперь $U$ принимает ещё больший набор суффиксов. Снова перейдём по суффиксной ссылке из текущего состояния и продолжим пытаться строить переходы.
2. Переход по $c$ из текущего состояния есть. Таким образом, для оставшихся суффиксов $sc$ уже существовуют свои состояния, на этом моменте следует остановиться и перейти к следующей части алгоритма.

Опять есть два случая: первый - ни из одного состояния, в котором мы побывали, перехода по $c$ не нашлось, и в итоге мы перешли по суффиксной ссылке из корня "в никуда". Тогда все суффиксы $sc$ принимаются одним состоянием $U$, так что суффиксную ссылку из $U$ мы проведём в корень, префиксную - в $X$ - и завершим алгоритм. 

Второй случай: в какой-то момент мы попали в состояние $P$, из которого уже был переход по $c$. Этот случай сложнее, и он также предполагает два возможных варианта.
Обозначим за $Q$ состояние, в которое ведёт переход по символу $c$ из $P$. Пусть самая длинная строка, принимаемая $P$ - это $l$. Снова рассмотрим два случая:
1. Префиксная ссылка из $Q$ ведёт в $P$. Это означает, что состояние $Q$, как и все достижимые по суфф. ссылкам из $Q$ состояния, принимает только суффиксы $sc$: исходя из определения префиксной ссылки, $l$ является самой длинной строкой, принимаемой $Q$, с приписанным в конце символом $c$, то есть суффиксом $sc$, а все остальные строки, принимаемыми $P$, являются суффиксами самой длинной.
2. Префиксная ссылка из $Q$ ведёт не в $P$. Это означает, что существует строка, принимаемая $Q$, длина которой больше, чем $lc$; но такая строка если и является суффиксом $sc$, то из одного из ранее посещённых (в первой части алгоритма) состояний есть переход по $c$ - противоречие; значит, $Q$ помимо суффиксов $sc$ также принимает строки, не являющиеся суффиксами $sc$, что недопустимо. Поэтому мы должны сделать две версии $Q$: одна принимает строки старого $Q$, являющиеся суффиксами $sc$ - назовём их основным набором, а вторая - все остальные строки $Q$ - назовём их дополнительным набором. 
Для этого клонируем состояние $Q$: создадим новое состояние $Q'$, которое будет отвечать за строки основного набора, скопируем в него все переходы, которые были в $Q$ и скопируем суффиксную ссылку из $Q$. Префиксную ссылку из $Q'$ проведём в $P$. Состояние $Q$ теперь будет отвечать только за строки дополнительного набора, поэтому мы должны перенаправить его суффссылку в $Q'$. Суффиксная ссылка из $U$ также должна указывать на $Q'$, т.к. все суффиксы $sc$ большей длины уже принимаются $U$. Осталось только перенаправить некоторые переходы, ведущие в $Q$, на состояние $Q'$: заметим, что это будут в точности все переходы по $c$ в $Q'$ из всех состояний, достижимых по суффиксным ссылкам из $P$, включая $P$. 

Для строки длины 0 суффиксный автомат - это единственное, корневое состояние.
Таким образом, мы получили корректный алгоритм построения суффиксного автомата.
   
Связь между суффиксным автоматом и суффиксным деревом
-----------------------------------------------------

Рассмотрим ребро в суффиксном дереве строки $T$, а точнее все подстроки
$T$, которым соответствует или "внутренняя" вершина ребра, или вершина,
в которой ребро заканчивается. Для любой строки $x$ и любой пары строк
$a$, $b$ из рассматриваемого множества строк, строки $xa$ и $xb$
являются или не являются префиксами строки $s$ одновременно.

Пусть $|a| < |b|$. Тогда $a$ является предком $b$ в боре, то есть, её
префиксом, значит, её множество вхождений точно содержит множество
вхождений строки $b$. Допустим, существует позиция $|x|$, в которой есть
вхождение строки $a$, но не строки $b$.

Рассмотрим строку $a'$, которая является максимальным префиксом строки
$b$, который можно встретить в той позиции. Если $a'$ не упирается в
конец строки, то её можно продолжить, как минимум, двумя различными
символами чтобы она осталась подстрокой $T$. Значит, соответствующая ей
вершина в дереве имеет степень больше двух и должна разбивать ребро, на
котором находится, что конфликтует с предположением о том, что $a$ и $b$
взяты с одного ребра.

Если же $a'$ нельзя продолжить, то она всё ещё должна разбивать ребро,
т.к. является суффиксом строки и её вершина не будет удалена при сжатии
рёбер.

Аналогичным образом можно показать, что для любой строки $a$ все строки
$b$ с таким же множеством строк $x$ находятся на соответствующем строке
$a$ ребре, то есть, есть биекция между рёбрами суффиксного дерева и
множествами левых позиций вхождений строк в $T$. Отсюда:

Для любого состояния $q$ суффиксного автомата строки $T$ найдётся
вершина $q'$ суффиксного дерева развернутой строки $T$ такая, что
множество строк, принимаемых состоянием $q$, совпадает с развёрнутым
множеством строк, таких что соответствующая им вершина в дереве лежит на
ребре, ведущем в $q'$ (включая строку, соответствующую $q'$).

Это целиком описывает состояния автомата и позволяет разработать
алгоритм его построения.
Код суффиксного автомата можно найти в конце статьи.

Время работы
============

Достаточно очевидно, что вершин в автомате (и, соответственно, префиксных и суффиксных ссылок) не более $2n$ - действительно, для каждого символа добавляется ровно одно состояние и клонируется максимум одно.
Переходов, очевидно, не более $nk$, однако можем дать более строгую оценку сверху в $3n$. Сплошных переходов - т.е. ведущих в состояние $X$ из состояния, достижимого по префиксной ссылке $X$ - не более $2n$. Рассмотрим переходы, не являющиеся сплошными. Состояния, принимающие суффиксы строки, назовём терминальными. Каждому из оставшихся переходов поставим в соответствие строку $t_{1}ct_{2}$, где $c$ - символ на ребре, $t_1$ - самая длинная строка, принимаемая "истоком" перехода, а $t_2$ - самая длинная строка, ведущая из "стока" перехода до некоторого терминального состояния. Заметим, что $t_1$ и $t_2$ образованы только сплошными переходами (т.к. если от одного состояния до другого есть некоторый путь, то есть не менее короткий путь, проходящий только по сплошным переходам). Также заметим, что во-первых, полученная строка будет являться некоторым суффиксом исходной, а во-вторых, так как все переходы кроме одного в таком пути сплошные, все такие строки будут различными. Из этих двух фактов следует, что количество несплошных переходов не более $n$, так как у строки ровно $n$ суффиксов. Таким образом, переходов в автомате не более $3n$, а ссылок не более $4n$, то есть автомат линеен по памяти.
По сути, доказав асимптотику по памяти, мы почти доказали время работы, и неочевидным остаётся только то, за сколько работает перенаправление переходов после клонирования. Заметим, что если мы добавляли символ $c$ и клонировали состояние $Q$ и получили $Q'$, то не может быть такого, что через какое-то время мы добавим символ $c$ и нам пришлось клонировать $Q'$ и, соответственно, перенаправлять переходы по $c$, ведущие в $Q'$. Доказательство: из $P$ обязательно есть переход по символу $c$ в $Q'$, причём этот переход сплошной, и такие переходы есть только из $P$ и некоторых достижимых из него по суффиксным ссылкам состояний. Также заметим, что для некоторого $k \geq 0$ и только для него из всех состояний, достижимых из $P$ за $k$ переходов по суффиксным ссылкам, будет существовать переход в $Q'$. Таким образом, ни один клон не будет клонирован повторно, а все остальные вершины будут клонированы максимум один раз, то есть каждый переход будет перенаправлен максимум один раз, а переходов линейное число, поэтому суммарно будет совершено $O(n)$ действий для перенаправления. Итак, мы доказали, что суффиксный автомат линеен по памяти и требует $O(n log k)$ времени на построение. TODO доказательство неверное

Применение в решении задач
==========================

1. **Число различных подстрок.** Дана строка $s$, необходимо посчитать
   
   количество её различных подстрок. В каждом состоянии встречаются
   
   строки длины от $len(link(q)) + 1$ до $len(q)$. Всего
   
   $len(q) - len(link(q))$ строк. Просуммировав эту величину по всем
   
   состояниям, получим ответ.
   
   *Упражнение:* решите эту же задачу за $O(n)$, учитывая, что к строке
   
   $s$ символы дописываются по одному и после каждого нового символа
   
   необходимо сказать текущее число различных подстрок строки $s$.
   
   *Упражнение\*:* Возьмём задачу из предыдущего упражнения и скажем,
   
   что теперь мы можем не только дописывать символы *в конец*, но и
   
   удалять их *с начала* строки. Вам требуется отвечать на те же
   
   запросы. Время работы решения всё ещё должно линейно зависеть от
   
   размера входа. *Подсказка:* иногда алгоритм Укконена также бывает
   
   полезен.

2. **Поиск подстрок в тексте.** Пропустив строку через автомат мы
   
   сможем сказать, входит ли она в текст. Допустим, мы хотим узнать
   
   какую-то информацию о её вхождениях. Например, нам нужно выдать
   
   любое конкретное вхождение. Как мы уже знаем, каждому вхождению
   
   соответствует строка $x$ такая что $ax$ --- суффикс $s$. Или, проще
   
   говоря, путь из состояния $q$ в какое-то финальное состояние.
   
   Динамикой по автомату как ациклическому ориентированному графу мы
   
   можем найти длину какого-нибудь такого пути (например, для
   
   определённости минимального или максимального). Отметим, что
   
   аналогичной динамикой считаются многие другие полезные значения,
   
   например, количество строк в правом контексте состояния (или, что то
   
   же самое, количество вхождений строк из состояния в $s$).
   
   Альтернативным решением будет обратиться к дереву суффиксных ссылок,
   
   которое, как мы помним, является суффиксным деревом для $s^T$. Как
   
   мы упоминали в самом начале, любая подстрока строки $s$ является
   
   префиксом одного из суффиксов исходной строки. Таким образом, если
   
   мы запишем в каждую "суффиксную" вершину индекс соответствующего ей
   
   суффикса, то все позиции вхождений строки $t$ в $s$ можно будет
   
   обнаружить в поддереве вершины, которая соответствует строке $t$.
   
   Значит, в частности, динамикой можно будет найти самое первое или
   
   самое последнее вхождение.
   
   Более того, учитывая, что в последнем случае мы работали с деревом,
   
   мы можем обойти его таким образом, чтобы на каждом шаге иметь в
   
   вершине множество возможных позиций, в которых встречаются строки из
   
   соответствующего состояния. Для этого нужно применить идею быстрого
   
   слияния множеств, когда мы всегда добавляем элементы из меньшего
   
   множества в большее, а не наоборот. Тогда такой обход потребует
   
   $O(n \log n)$ операций добавления в множество, т.к. каждый раз когда
   
   мы переносим между множествами элемент $k$, размер нового множества
   
   будет как минимум, в два раза больше старого, в котором он хранился.
   
   *Упражнение\*:* дана строка $s$. Найти число строк $t$ таких, что
   
   они имеют хотя бы $3$ *непересекающихся* вхождения в строку $s$.

3. **Наибольшая общая подстрока.** Нам дано $k$ строк
   
   $s_1, s_2, \dots, s_k$. Нужно найти наибольшую строку $t$, которая
   
   встречается в каждой из строк $s_i$. Одно из возможных решений ---
   
   построить автомат для строки $s_1 t_1 s_2 t_2 \dots s_n t_n$, где
   
   $t_i$ --- уникальный для каждой строки символ-разделитель. Теперь мы
   
   можем завести динамику $dp[q][i]$, в которой хранить $1$, если из
   
   состояния $q$ можно добраться до состояния, из которого есть переход
   
   по $t_i$, не проходя при этом через другие символы-разделители. Это
   
   будет равносильно тому, что строки из $q$ входят в $s_i$. Как и в
   
   прошлый раз, динамику можно пересчитывать по топологической
   
   сортировке автомата как ориентированного ациклического графа. Итого
   
   решение будет работать за $O(k \cdot \sum |s_i|)$.
   
   *Упражнение\*:* решить указанную задачу за $O(\sum |s_i|)$.
   
   ## Модификация суффиксного автомата
   
   Эта модификация была придумана и рассказана Филиппом Грибовым, в частности, в рамках программы третьего курса кружка по алгоритмам Tinkoff Generation (2018-2019).
   Суть заключается в следующем: заметим, что при построении и доказательстве асимптотики на самом деле мы никак не использовали, что строится автомат только для одной строки. То есть после того, как мы построили суффиксный автомат по некоторой строке, мы можем сказать, что вершина, принимающая всю строку (last) - это корень автомата, и спокойно добавить в автомат вторую строку, и после этого автомат будет принимать все различные подстроки как первой, так и второй строк. Очевидно, можно так же построить автомат и для трёх, четырёх и т.д. строк, что даёт нам просто решать такие сложные задачи, как следующая:

> Дан словарь строк, изначально пустой. Приходят запросы трёх типов: добавить строку в словарь, если её нет, удалить строку из словаря, если она есть, и найти суммарное количество вхождений строк словаря в заданный текст. Задача в онлайн.

   Сперва введём вспомогательное понятие. *Подавтоматом* состояния $U$ суффиксного автомата называется такой его подграф, что в нём есть пути по всем подстрокам самой длинной принимаемой $U$ строки и только по ним. Обойти подавтомат можно простой рекурсивной функцией типа DFS: по сути, для этого нам нужно пройтись по всем суффиксам всех префиксов (или наоборот) данной строки, то есть если мы находимся в состоянии $X$, то мы либо ничего не делаем, если $X$ уже была посещена этим обходом, либо запускаем функцию сначала от вершины, достижимой по префиксной ссылке, а затем по суффиксной. 
   Теперь можно перейти к решению задачи.
   Для обработки запроса первого типа просто добавим строку в суффиксный автомат и пометим последнюю вершину как терминальную, т.е. отвечающую за одну из строк.
   Для обработки запроса второго типа найдём вершину, отвечающую за данную строку, и если она есть, просто снимем терминальную пометку.
   Для обработки запроса третьего типа добавим заданную строку в суффиксный автомат и пройдёмся по её подавтомату, при этом запоминая для каждой вершины количество вершин с терминальной меткой в её подавтомате. Тогда если мы попали в уже посещённую во время обхода подавтомата вершину, то просто прибавим уже посчитанный для неё ответ. 
   Осталось только понять асимптотику, ведь если в автомате есть несколько строк, то может случиться так, что у некоторых размер подавтомата будет порядка квадрата от их длины.
   Пусть суммарная длина всех строк запросов это $m$.
   Давайте разделим строки на тяжёлые (длина больше $\sqrt{m}$) и лёгкие (длина не больше $\sqrt{m}$). тяжёлых строк не больше $\sqrt{m}$, и при этом размер подавтомата любой строки не больше $O(m)$, поэтому суммарное время обработки тяжёлых строк не больше $O(m \sqrt{m}). Лёгких строк может быть много, и размер подавтомата строки длиной $l$ может быть $O(l^2)$, что не больше, чем $O(\sqrt{m})$; суммарная длина всех строк не больше $m$, а значит суммарное время на обработку всех лёгких строк также порядка $O(m \sqrt{m})$. Таким образом, мы получили довольно простое решение такой задачи за $O(m \sqrt{m})$ с небольшой константой, которое заходит даже для $m$ порядка $10^6$.
   И таким образом можно строить не только суффиксный автомат по нескольким строкам: можно "подвешивать" одну строку к другой и т.д.
   
### Реализация

  ```c++
  struct node {
    int link = -1, p = -1, len = 0; // Суффиксная, префиксная ссылки и максимальная длина принимаемой состоянием строки, соответственно
    char pc = '#'; // Символы, переходы по которым ведут в состояние
    map<char, int> next; // Переходы по символам

    node() {}

    node(int p, int len, char pc) : p(p), len(len), pc(pc) {}
};

node v[2 * MAXN]; // MAXN - максимально возможная суммарная длина строк
int mx = 0; // номер последнего добавленного состояния

int add_char(int ls, char c) { // ls - состояние, к которому мы "подвешиваем" следующий символ, c - сам символ
    if (v[ls].next.find(c) != v[ls].end()) return v[ls].next[c]; // Если переход по символу c из ls уже был, то ничего добавлять не надо
    v[++mx] = node(ls, v[ls].len + 1, c);
    int p = ls;
    for (; p != -1 && v[p].next.find(c) == v[p].end(); p = v[p].link)
        v[p].next[c] = mx;
    if (p == -1) {
        v[mx].link = 0; // Если перехода по c не нашлось
        return mx;
    }
    int q = v[p].next[c];
    if (v[q].p == p) {
        v[mx].link = q;
        return mx;
    }
    v[++mx] = node(p, v[p].len + 1, c); // Клонирование
    v[mx].next = v[q].next; v[mx].link = v[q].link;
    v[q].link = v[mx - 1].link = mx;
    for (; p != -1 && v[p].next[c] == q; p = v[p].link)
        v[p].next[c] = mx;
    return mx - 1;
}

int used[MAXN * 2]; // Массив времён посещения обходом подавтомата

void subautomaton(int x, int tm) { // Обход подавтомата
    if (x == -1 || used[x] == tm) return;

    used[x] = tm;
    //....

    subautomaton(v[x].p, tm);
    subautomaton(v[x].link, tm);
}
  ```


## Автомат

Здесь суффиксный автомат описан совсем не так, как это принято, зато это
гораздо понятнее. ![Пример_автомата.png](Пример_автомата.png
"Пример_автомата.png") Представим себе ориентированный граф, в
котором на каждом ребре записано по букве. Так же выделим одну из
вершин и назовём её стартовой. Замечаем, что в таком графе каждый
путь от стратовой вершины до какой-то будет задан определённой строкой.
Рассмотрим следующий пример:

В автомате 3 вершины: start, 1, 2, есть ребро от start к 1, на котором
написаны буквы «a» и «b» и есть ребро от 1 к 2, на котором написано
«c». Заметим, что в таком автомате от start есть 5 путей: пустой путь,
путь через «a» в 1, путь через «b» в 1, путь через «a» а потом через «c»
в 2, пусть через «a» а потом через «c» в 3. Т.е возможные пути заданы
строками «», «a», «b», «ac», «bc».

Таким образом в автомат можно передать строки и итерируясь по символам
строки можно переходить из одной вершины в другую. В предыдущем
примере в автомат можно передать строку «ac» и после этого мы
окажемся в вершине 2. Но строку «bd» в предыдущий автомат передать
нельзя, так как из 1 нет ребер по символу «d».

### Основные понятия

В автомате вершины принято называть **состояниями**, а рёбра —
**переходами**.

Автомат называется **детерминированным**, если из любого состояния не
существует двух переходов по одинаковым символам. Это означает, что
для каждой строки есть не более одного пути, соответствующего ей и
передав строку автомату мы однозначно знаем, куда по ней мы
перейдём, если путь по ней существует.

Автомат называется **конечным**, если нём конечное число вершин.

Некоторые вершины автомата будут помечены как **терминальные**.
Считается, что **автомат принял строку** если существует путь,
соответствующий этой строке и в конце, пройдя по пути, мы окажемся в
терминальной вершине.

## Суффиксный автомат

Если это определение у вас вызвало ужас и абсолютное непонимание
происходящего, посмотрите все термины в предыдущем разделе.
Далее все эти страшные слова мы почти не будем использовать.

| Примеры автоматов                                                                               |
| ----------------------------------------------------------------------------------------------- |
| Бор, построенный на всех суффиксах строки нам вполне подойдёт. Для примера возьмём строку «abc» |
| ![Пример_суффавтомата_1.png](Пример_суффавтомата_1.png "Пример_суффавтомата_1.png")           |

А теперь перейдём к алгоритму, строющему суффиксный автомат размера
$O(n)$, где $n$ — длина строки. Теория будет сильно отличаться от
общепринятой в сторону большей понятности. Но для начала введём
некоторые дополнительные правила и заметим некоторые вещи.

### Дополнительные правила

Для каждой вершины в автомате есть какой-то набор строк, пути по которым
заканчиваются в этой вершине. Тогда будем поддерживать следующее
правило. **Для каждой вершины все строки, ведущие в неё должны
являться суффиксами друг друга.** Причём эти суффиксы должны являться
подряд идущими по длине. Т.е если $s$ — максимальная по длине строка,
которая ведёт в вершину и если $k$ — длина $s$, то в вершину ведут
строки $s\[0:k\], s\[1:k\], s\[2:k\], s\[3:k\], \\ldots, s\[l:k\]$.
Итого в вершину будет вести $l + 1$ строка, причём все строки будут
является суффиксами $s$ длины хотя-бы $k - l$. Соответственно наборы
(«z») или («abc», «bc», «c») или («abacaba», «bacaba», «acaba») могут
являться полным набором строк, ведущих в вершину, а наборы
(«abacaba», «abacab») или («abcd», «cd», «d») или («abacab», «bacab»)
не могут являться полным набором строк, ведущих в вершину.

Будем говорить, что **вершине соответствует максимальная строка, которая
в неё ведёт**. Т.е. если в вершину ведёт единственная строка («z»), то
этой вершине соответствует «z», если в вершину ведут строки («abc»,
«bc», «c»), то вершине соответствует «abc», если в вершину ведут строки
(«abacaba», «bacaba», «acaba»), то вершине соответствует строка
«abacaba».

По аналогии с Ахо-Карасиком, мы можем ввести понятие **суффиксная
ссылка**. Как мы уже знаем, вершина $A$ принимает строки
$s\[0:k\], s\[1:k\], s\[2:k\], s\[3:k\], \\ldots, s\[l:k\]$ (Суффиксы
$s$ длиной $k, k - 1, \\ldots, k - l$). А где-то должна быть вершина
$B$, в которую ведёт строка $s\[l + 1:k\]$ (Суффикс $s$, имеющий длину
$k - l - 1$). Ещё одним правилом суфф. автомата будет то, что
максимальная по длине строка, которая ведёт в $B$ должна быть
$s\[l + 1:k\]$. И тогда все строки, которые ведут в $B$ будут иметь вид
$s\[l + 1:k\], s\[l + 2:k\], \\ldots, s\[l + t:k\]$, (суффиксы $s$,
имеющие длину от $k - l - t$ до $k - l - 1$). Другими словами
вершина $B$ будет принимать следующие суффиксы $s$ после вершины
$A$. Тогда будем считать, что из $A$ суффиксная ссылка ведёт в вершину
$B$. Тогда из каждой вершины кроме стартовой будет по одной суффиксной
ссылке.

### Важные замечания

Тогда заметим несколько важных вещей. Возьмём любую вершину $A$.
Заметим, что так как все строки, которые в неё ведут, являются
суффиксами друг друга, то они все заканчиваются на один и тот же
символ. Значит все переходы в $A$ ведутся по одному и тому же
символу, и только по нему.

Вообще в $A$ могут вести переходы из разных вершин. Каждой из них
соответствует какая-то строка. Ту из них, которой соответствует
самая длинная строка, будем называть **предком вершины $A$**.

Как мы уже знаем, в вершину $A$ ведут строки $s\[0:k\], s\[1:k\],
s\[2:k\], s\[3:k\], \\ldots, s\[l:k\]$. Теперь посмотрим на все вершины,
из которых есть переход в $A$. Тогда эти вершины ведут строки $s\[0:k -
1\], s\[1:k - 1\], s\[2:k - 1\], s\[3:k - 1\], \\ldots, s\[l:k - 1\]$, и
только они. И замечаем, что тогда между этими вершинами как-то
расставлены суффиксные ссылки, причём если от предка $A$
спускаться по суффиксным ссылкам, то мы будем идти по вершинам, из
которых есть переход в $A$ пока не попадём в какую-то вершину, из
которой в $A$ перехода нет. При этом мы пройдём по всем вершинам,
из которых есть переход в $A$ и в конце мы окажемся в вершине, которой
соответствует строка $s\[l + 1:k - 1\]$. Заметем, что тогда из этой
вершины будет идти переход суффиксную ссылку вершины $A$, и эта
вершина как раз будет предком суффиксной ссылки $A$.

И наконец заметим последнюю вещь. Если из вершины есть переход по
какому-то символу $c$, то есть вершина, в которую ведёт строка $s
+ c$, а значит в исходной строке был какой-то суффикс, начинающийся с $s
+ c$. Тогда у этой же строки есть суффикс, начинающийся с $s\[l + 1:k\]
+ c$. Тогда из суффиксной ссылки вершины $A$ тоже должен быть переход по
символу $c$. Тогда посмотрим, куда ведут эти 2 перехода. Они могут вести
в одну и ту же вершину, а могут вести в разные. Если они ведут в разные,
то в первую точно ведёт строка $s\[l:k\] + c$ (самая минимальная строка,
ведущая в $A$ с приписанным к ней символом $c$), а во вторую ведёт
строка $s\[l + 1:k\] + c$ (строка, соответствующая суффиксной
ссылке из $A$, с приписанным к ней символом $c$). Замечаем, что это
последовательные суффиксы друг друга, значит из первой вершины должна
вести суффиксная ссылка во вторую.

### Алгоритм

Мы разобрались со всеми определениями, и теперь пора перейти к
алгоритму. Алгоритм гораздо легче всей теории, за ним стоящей.

Будем строить суффавтомат итеративно, т.е будем достраивать суффавтомат
при приписывании к исходной строке нового символа.

Посмотрим на вершину $A$, которой соответствует вся строка. Как мы
знаем, в неё ведёт несколько последовательных суффиксов строки, а
следующие суффиксы ведут в её суффиксную ссылку. Если спускаться от
этой вершины по суффиксным ссылкам, то мы посетим все *терминальные*
вершины суфф. автомата и только их.

Пусть мы дописали к автомату символ $ch$. Тогда нам надо, чтобы автомат
принимал любой суффикс исходной строки с приписанным к нему символом
$ch$. Тогда как-то менять нам надо только терминальные вершины, и то не
все, ведь из некоторых уже мог быть переход по $ch$.

Делать мы это будем так: создадим вершину $B$ и проведём в неё переход
по символу $ch$ из $A$. Далее перейдём в суффиксную ссылку из $A$.
Назовём теперь эту вершину именем $A$. Если из нового $A$ нет
перехода по символу $ch$, то проведём его тоже в вершину $B$.
Далее снова перейдём в суфф. ссылку из $A$, и снова назовём теперь
эту вершину именем $A$. Будем продолжать так делать пока из $A$ не
появится переход по символу $ch$. Пусть этот переход ведёт в вершину
$C$. У нас возможно 2 варианта: $A$ — предок $C$ или $A$ — не предок
вершины $C$.

В первом случае всё просто. Проведём суфф ссылку из $B$ в $C$. Замечаем,
что после этого для всех старых вершин свойства суффавтомата выполнены,
в $B$ будут вести последовательные суффиксы исходной строки с
приписанным символом $ch$, и из $B$ будет существовать
корректная суффиксная ссылка. Тогда если в новом суффавтомате
пометить терминальными все вершины, которые мы посетим спуском из $B$
по суфф. ссылкам, то автомат будет корректным и будет принимать только
суффиксы начальной строки с приписаным символом $ch$.

Во втором случае всё тоже просто, но не совсем. Из вершины $B$ мы не
можем пустить суфф. ссылку в вершину $C$, потому что в $C$ ведут
некоторые строки, не являющиеся суффиксами $B$. Но замечаем, что
строка, которая соответствует $A$ с приписанным к ней символом $ch$
ведёт в $C$ и является самым большим суффиксом $B$, не ведущим в $B$.
Тогда сделаем следующую вещь. Возьмём вершину $C$ и раздвоим её.
Вернее отделим от неё кусок. Возьмём строку, соответствующую $A$,
припишем к ней $ch$ и возьмём все её суффиксы, лежащие в $C$. И
создадим вершину $D$, в которую будут вести только эти строки.
Чтобы эти строки вели в $D$, надо провести туда переходы. Замечаем,
что строка, соответствующая $A$ с приписанным $ch$ будет
соответствовать $D$, а значит $A$ будет являться предком
$D$. Дальше будем спускаться по суффиксным ссылкам из $A$, и пока
переход по символу $ch$ будет вести в $C$, будем менять его на
$D$, а если переход будет вести куда-то в другое место, то это будет
означать, что мы пройдём все вершины, которым соответствуют суффиксы
$A$ и из которых переход по $ch$ раньше вёл в $C$. После этого переходы
в $D$ будут корректно построены. После этого построим корректно
суффиксные ссылки. Проведём из $C$ суффиксную ссылку в $D$ и
проведём из $D$ суффиксную ссылку туда, куда она раньше вела из $C$.
Так как вершина $D$ является отделённым куском вершина $C$, то все
переходы из $D$ будут такими-же, как все переходы из $C$. Тогда
замечаем, что после такого разделения вершины $C$ на 2 части автомат
всё ещё корректный и его правила выполняются. А так же замечаем, что
теперь из $A$ переход по $ch$ ведёт в $D$, и $A$ — предок $D$. Тогда
мы свели этот случай к предыдущему и теперь нам достаточно построить
переход из $B$ в $D$, и суффавтомат построен. Разумеется, вершины
надо помечать терминальными не после каждого добавления символа, а
только в самом конце. {{ Утверждение |Название=Время работы |Показать
название=1 |Утверждение=Время построения суффиксного автомата
составляет $O(N)$. |Доказательство=Во первых мы каждый раз
создавали не более 2 вершин, т.е. всего вершин $O(n)$. Мы много раз
спускались по суффиксным ссылкам из $A$, назовём балансом вершины длину
пути от неё до корня по суфф. ссылкам. Тогда баланс $B$ в первом случае
это баланс $C$ плюс 1. А баланс $C$ не превышает баланс конечного $A$
плюс 1, т.к. предки вершин на пути от $C$ до корня различны и лежат на
пути от конечного $A$ до корня. Тогда если баланс $B$ равен балансу $A$
плюс 1 минус число спусков по $A$. Тогда как было с Ахо-карасиком,
число спусков не превышает $n$. Про то, что раздвоение быстро
работает можно тоже доказать, но мне лень это писать, так что
подумайте сами. В общем там всё работает быстро и общее построение
работает за $O(N)$. }}

### Пример реализации

Звучит это всё страшно, но пишется в 40 строк, вот реализация на питоне
с кучей ошибок, чтобы вы не копипастили.

``` Python numberLines
# Здесь много ошибок, код нужен только для ознакомления

class node:
    def init(self):
        self.nx = [-1] * 26 # Переходы
        self.p = -1         # Суффиксная ссылка
        self.pre = -1       # Предок

s = [node()]

# Мы по умолчанию считаем, что суффиксная ссылка из корня ведёт в -1

def add(a, ch): # a - последняя вершина в автомате, ch - добавляемый символ
    # Создаём вершину b и указываем её правильные параметры
    b = len(s)
    s.append(node())
    s[b].p = 0 # Обратите внимание на это, возможно мы так и не дойдём до вершины С
               # и тогда суффиксная ссылка из b должна указывать на 0
    s[b].pre = -1
    while a != -1:
        if (s[a].nx[ch] == -1):
            # Случай, когда из а нет перехода по ch
            s[b].nx[ch] = a
            a = s[a].p
            continue
        # c - то, куда ведёт переход из a по ch
        c = s[a].nx[ch]
        # Проверяем, что предок c это a и в этом случае меняем суфф. ссылку b
        if (s[c].pre == a):
            s[b].p = a
            break
        # Иначе создаём вершину d
        d = len(s)
        s.append(node())
        # Меняем суфф. ссылки
        s[c].p = d
        s[b].p = d
        s[d].p = s[c].p
        # Назначаем предка d
        s[d].pre = b
        # Копируем переходы
        s[d].nx = s[c].nx
        # Добавляем предков вершины d, пройдясь вниз по суфф. ссылкам из a
        while (a != -1 and s[a].nx[ch] == b):
            s[a].nx[ch] = d
            a = s[a].pre
        break
    # Если строк несколько, то возможно мы не добавили b. Поэтому надо возвращать вот это
    return s[s[b].pre].nx[ch]
```

## Задачи

### Количество различных подстрок

Замечаем, что любая подстрока строки — это начало какого-то суффикса.
Тогда в нашем автомате любой путь — это подстрока начальной строки, и
для любой подстроки существует путь в автомате по ней. Тогда первый
способ найти число подстрок данной строки — посчитать число путей в
автомате. Это можно сделать обычным ДФСом, путём подсчёта для каждой
вершины числа путей из неё (только надо запоминать уже посещённые
вершины, чтобы 2 раза не ходить). Есть второй способ. Каждый путь
заканчивается в какой-то вершине. Тогда для каждой вершины можно
посчитать число путей, в неё ведущих. Это можно делать как в
процессе построения (но не забывать про пересчёт числа путей в
раздваиваемые вершины), так и после. Тогда сумма по кол-ву путей,
заканчивающихся в каждой вершине автомата это число различных путей
в автомате, т.е. число подстрок данной строки. Этот способ так же
позволяет найти число подстрок у каждого префикса строки, так как
в процессе построения автомата мы поочерёдно строим суффавтомат для
каждого префикса нашей строки.

### Рефрен

Рефрен это такая подстрока данной нам строки, что произведение её длины
на число вхождений в нашу строку максимально. Найти рефрен очень
просто. Замечаем, что число вхождений подстроки в строку это число
суффиксов строки, что эта подстрока — начало этого суффикса. Тогда число
вхождений подстроки в строку это число путей из вершины, соответствующей
этой подстроке, в терминальные вершины. Тогда для каждой вершины
посчитаем число путей из неё в терминальные вершины (это
делается так же, как и подсчёт числа просто путей из вершины), а
так же для каждой вершины посчитаем длину строки, которая ей
соответствует. Переберём все вершины и найдём ту, у которой
произведение длины на число путей до терминальных вершин будет
максимально. Строка, соответствующая этой вершине это и есть
рефрен.

## Суффиксный автомат для нескольких строк

Всё что будет описано дальше вы нигде больше не прочитаете, потому что
никто этого не знает.

Пока мы строили суффавтомат для одной строки. Но замечаем, что при
добавлении символа мы никак не использовали то, что суффавтомат
должен быть конкретно для одной строки. Мы использовали только то,
что вершина принимает последовательные суффиксы и то, что существует
суффиксная ссылка. В частности это означало, что если в суффавтомате
есть путь, соответствующий какой-то строке, то есть путь,
соответствующий любому суффиксу данной строки, а значит и
вообще любой подстроке данной строки. Тогда заметим, что мы можем
просто взять любую вершину, и дописать к ней переход по какому-то
символу, используя наш алгоритм. И никаких проблем от этого не будет.
Тогда перейдём к следующей задаче.

### Подавтомат

Рассмотрим следующую задачу. Дан набор из $n$ строк, с суммарной длиной
$m$. Для каждого $1 \\le k \\le n$ найти максимальную длину строки,
являющейся подстрокой хотя-бы $k$ строк из набора.

Для начала построим суффавтомат, который принимает все суффиксы всех
строк из набора. Это делается так: сначала построим автомат для
первой строки. Дальше пользуясь важным замечанием возьмём корень
автомата, и припишем к нему первый символ второй строки. К этой
вершине припишем второй символ второй строки и т. д. (Обратите
внимание, что функцию $add$ надо вызывать даже если переход по
символу уже был, так как возможно нам придётся раздваивать
следующую вершину. Именно поэтому в функции $add$ из примера
такой странный return, ведь возможно мы не добавляли перехода в
вершину $b$). Так мы получим автомат, принимающий все суффиксы
первых двух строк. Дальше так же туда припишем третью, четвёртую и
т.д. строки. По сути у нас автомат превратился в бор с уже готовыми
суфф. ссылками и принимающий не только строки, но и все их
подстроки.

![Пример_суффавтомата_3.png](Пример_суффавтомата_3.png
"Пример_суффавтомата_3.png") Вы наверное думаете, что
всякие-там термины уже закончились. А вот нет.

Если рассмотреть уже встречавшийся ранее пример суфф. автомата для
строки «aabab», то в подавтомат вершины 3 войдут вершины $start,
1, 2, 3, 6t$, в подавтомат вершины $6t$ войдут вершины $start, 1, 6t$, а
в подавтомат вершины $2$ войдут только вершины $start, 1, 2$.

Заметим, что чтобы построить подватомат вершины $A$, нам достаточно
построить подавтомат её предка, а так же добавить туда все вершины,
достижимые из $A$ спуском по суфф. ссылкам. (Это верно, так как
подавтомат предка принимает подстроки $A$ без последнего
символа, а оставшиеся подстроки $A$ это суффиксы $A$, т.е. то,
что мы пройдём, когда будем спускаться по суфф. ссылкам. Заметим, что
тогда мы можем сказать, что подавтомат вершины $A$ это сама вершина $A$
и объединение подавтоматов её суфф. ссылки и её предка. А тогда с
помощью очень простой рекурсивной функции $subautomaton$ мы можем
пройти по всем вершинам подавтомата.

``` Python numberLines
class node:
    def init(self):
        self.nx = [-1] * 26 # Переходы
        self.p = -1         # Суффиксная ссылка
        self.pre = -1       # Предок
        self.last_used = -1 # Время последнего посещения

s = [node()] # Список вершин

t = 0 # Временная метка построения подавтомата
      # (нужно чтобы не посещать одну и ту же вершину несколько раз)

# Делает какое-то действие для подавтомата вершины
# При каждом следующем запуске временную метку t надо менять
def subautomaton(a):
    # Проверка, что при этом построении подавтомата мы ещё не посещали вершину
    if (s[a].last_used == t):
        return
    s[a].last_used = t
    # Делаем какое-то действие
    subautomaton(s[a].p) # Идём в суфф. ссылку
    subautomaton(s[a].pre) # Идём в предка
```

Теперь вернёмся к задаче. Попробуем для каждой строки найти число строк
из набора, а которых эта строка является подстрокой. Для этого нам надо
для каждой вершины узнать, у скольких строк из из набора эта вершина
является подстрокой. А для этого нам достаточно посмотреть на каждую
вершину, соответствующую какой-то строке из набора. Мы знаем, что все
вершины в её подавтомате как раз являются её подстроками. Тогда для
каждой вершины заведём счётчик числа строк, в которой она является
подавтоматом. И для каждой строки из набора прибавим 1 к счётчикам
всех строк в подавтомате. Для каждой вершины так же запомним длину
строки, соответствующей этой вершине. И дальше просто переберём все
вершины и обновим через них ответ.

Остаётся один непонятный вопрос — время работы нашего алгоритма. Это
только в обычном суффавтомате число вершин $O(n)$. Но тут берётся
подавтомат, и вообще может оказаться, что каждой подстроке
подавтомата соответствует по отдельной вершине, и тогда у нас
будет $l^2$ вершин в подавтомате, где $l$ — длина строки, для которой мы
строим подавтомат. Что-же, получается наш алгоритм работает за $O(n
\\cdot m^2)$. А вот нифига подобного. У нас всего вершин в автомате
будет $O(m)$, значит число вершин в податомате не больше $O(m)$. Но
асимптотика $O(n \\cdot m)$ нас тоже не очень-то устраивает. Тогда
разделим все строки из набра на короткие и длинные. В коротких
число символов должно быть не больше $\\sqrt{m}$, а в длинных может
быть больше. Заметим, что число длинных строк не больше $\\sqrt{m}$,
значит величина всех их подавтоматов $O(m \\cdot \\sqrt{m})$. А что
делать с короткими строками. Как мы знаем, для строки $l$, размер её
подавтомата не больше $l^2$. А это меньше, чем $l \\cdot \\sqrt{m}$.
Тогда суммарный размер подавтоматов коротких строк это $\\sum l \\cdot
\\sqrt{m} = \\sqrt{m} \\cdot \\sum l$. А сумма длин всех строк не больше
$m$. Тогда суммарный размер всех подавтоматов $O(m \\sqrt{m})$. Но так
как про эту идею никто не знает, никто не строит антитесты, на которых
это работает за $O(m \\sqrt{m})$. Поэтому этот алгоритм просто летает и
спокойно заходит даже при $m = 5\\,000\\,000$. И вот это вот позволяет
вам становиться богом строк и решать почти любую задачу на одну или
несколько строк. Скажем вот:

### Ахо-карасик в онлайне с линейной памятью

Есть 3 онлайн запроса: добавить в набор строку, удалить из набора строку
и для данной строки узнать суммарное число вхождений строк из набора в
качестве подстроки.

Запросы первого и второго вида будем обрабатывать очень просто. Если
пришла новая строка, то добавим её в автомат и пометим её последнюю
вершину терминальной. Если пришёл запрос удаления, то уберём
терминальную пометку.

На запрос третьего типа будем отвечать так: добавим строку в автомат,
пройдёмся по вершинам, отвечающим за префиксы этой строки. И будем
спускаться из них по суфф. ссылкам и если прошли через терминальную
вершину, то прибавлять 1 к ответу. Логично, что это будет долго
работать. Но сделаем так: если мы оказались в какой-то вершине,
через которую уже так вот спускались по суфф. ссылкам, то не будем
идти так же ещё раз, а просто прибавим заранее посчитанный ответ для
неё. Тогда по каждой вершине подавтомата данной строки мы пройдёмся по
разу. А значит время работы будет $O(m \\cdot \\sqrt{m})$.

## Завершение

Суфф. автоматом можно решать много других задач. Код суфф. автомата
очень простой, и часто для построения даже обычного ахо карасика
можно его заюзать. Так же если вдруг вам припрёт написать задачу не
суфф. автоматом, а суфф. деревом или суфф. массом, то сообщаем, что
Укконен — это явно не то, чем стоит строить суфф. дерево (а из него
уже суфф. масс). Просто постройте суфф. автомат для перевёрнутой
строки, возьмите дерево суффиксных ссылок, это и будет суфф.
дерево для начальной строки. Доказательство этого факта оставим
читателю в качестве упражнения.

И ещё раз напомню, что для дебага суфф. автомата надо использовать
строку «aabab». Если суфф. автомат на ней правильно построен, то с
вероятностью $99\\%$ ваш код правильный.

### Упражнения

Попробуйте решить сформулированную выше задачу про длину максимальной
подстроки у $k$ строк для каждого $k$, суммарно за линейное время.
