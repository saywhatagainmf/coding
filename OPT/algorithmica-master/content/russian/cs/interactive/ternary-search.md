---
title: Тернарный поиск
authors:
- Максим Иванов
weight: 2
draft: true
---


### Описание алгоритма

Научимся искать локальный максимум некоторой непрерывной функции $f$ на
отрезке $\[l, r\]$. Будем считать, что на данном отрезке есть только
один локальный максимум, то есть $f$ сначала возрастает, а потом
убывает.

Будем подерживать следующий инвариант - искомый максимум лежит на отрезке
$\[l, r\]$. Границы будем постепенно сдвигать к искомой точке, почти как
в [бинарном поиске](Бинарный_поиск "wikilink").

Поделим текущий отрезок на <b>три равные части</b>. Получим отрезки:
$\\left\[l, m_1\\right\]$, $\[m_1, m_2\]$, $\[m_2, r\]$. Теперь
сравним значения в точках $m_1$ и $m_2$.

  - Если $f(m_1) \> f(m_2)$, то максимум функции лежит на $\[l,
    m_2\]$. Правее $m_2$ его быть не может, так как тогда на $\[m_1,
    m_2\]$ функция убывает, а потом на $\[m_2, m_3\]$ возрастает, но
    мы требуем, чтобы сначала шел спад, а потом рост. Сдвинем границы
    следующим образом: $r \\rightarrow m_2$.
  - Если $f(m_1) \< f(m_2)$, то максимум лежит на $\[m_1, r\]$ по тем
    же соображениям, что и в предыдущем пункте. Изменим границы: $l
    \\rightarrow m_1$.

### Асимптотика

Заметим, что длина каждого отрезка разбиения составляет одну треть от
исходного, то есть длина отрезка, на котором мы ищем максимум каждый
раз умножается на $\\frac{2}{3}$. Если мы делаем поиск на массиве из
$n$ элементов, то мы сделаем примерно $\\log_{3/2}n$ итераций. То есть
асимптотика составит $O(\\log n)$, так как мы игнорируем основание
[логарифма](Логарифм "wikilink").

### Альтернативное решение

Как известно, локальный максимум функции $f$ - это просто такое $x_0$,
что для всех близких к нему $x$ значения $f(x) \< f(x_0)$. Для
непрерывных функций выполняется более сильное условие: слева от
максимума функция возрастает, а справа от максимума функция убывает.
Воспользуемся этим условием в бинарном поиске.

Если известно $x_1$ такое, что в его окрестности f(x) возрастает, и
$x_2$ такое, что в его окрестности f(x) убывает, то можно запустить
между ними бинпоиск и найти точку $x_0$ такую, что слева от нее
возрастает значение функции, а справа - убывает. Это и есть
локальный максимум.

А если функция выпуклая, то она вообще выглядит красиво: сначала
возрастает, потом максимум, потом убывает.

Чтобы по точке понять, значение функции убывает или возрастает в ее
окрестности , достаточно проверить две точки достаточно близко к
ней и сравнить значения $f$ в этих точках.

<em><b>Примечание:</b> такой подход еще называют бинарным поиском по
производной, так как сначала производная больше нуля, а потом меньше
нуля.</em>

### Отрезки с постоянным значением

![тернарный_поиск.png](тернарный_поиск.png "тернарный_поиск.png")

В описании функции $f$ мы потребовали <b>строгое</b> возрастание и
убывание. Объясним это ограничение. Для этого предположим, что
возможна нестрогая монотонность.

Будем искать локальный минимум. Допустим, у функции есть отрезок, где ее
значение постоянно. Отрезок поиска может измениться здесь двумя
способами - в зависимости от того, в какую из частей поиск идет
при равенстве. Если левая граница сдвинется на оранжевую линию, то поиск
останется на отрезке со значением $1$, что гораздо больше, чем настоящий
локальный минимум $0$.

Так мы только что научились находить корень непрерывной функции, у
которой мы знаем значение меньше и больше 0. Но можно ли найти с
помощью бинарного поиска локальный максимум функции? Можно\!

Как известно, локальный максимум функции $f$ - это просто такое $x_0$,
что для всех близких к нему $x$ значения $f(x) \< f(x_0)$. Для
непрерывных функций выполняется более крутая вещь: слева от
максимума функция возрастает, а справа от максимума функция
убывает. Так это как раз отличное условие для нашего
вещественного бинарного поиска\!

Если вы знаете $x_1$ такое, что в его окрестности f(x) возрастает, и
$x_2$ такое, что в его окрестности f(x) убывает, то можно запустить
между ними бинпоиск и найти точку $x_0$ такую, что слева от нее
возрастает значение функции, а справа - убывает. Это и есть
локальный максимум.

А если функция выпуклая, то она вообще выглядит красиво: сначала
возрастает, потом максимум, потом убывает.

Проблема только в одном: как по точке понять, в ее окрестности значение
функции убывает или возрастает? Достаточно тыкнуть две точки
очень-очень рядом с ней и сравнить их значения\!(очень-очень -
точка на расстоянии $\\epsilon \< 10^{-6}$

## Поиск максимума выпуклой функции: тернарный поиск, бинарный поиск

Так мы только что научились находить корень непрерывной функции, у которой мы знаем значение меньше и больше 0. Но можно ли найти с помощью бинарного поиска локальный максимум функции? Можно!

Как известно, локальный максимум функции $f$ - это просто такое $x_0$, что для всех близких к нему $x$ значения $f(x) < f(x_0)$. Для непрерывных функций выполняется более крутая вещь: слева от максимума функция возрастает, а справа от максимума функция убывает. Так это как раз отличное условие для нашего вещественного бинарного поиска!

Если вы знаете $x_1$ такое, что в его окрестности f(x) возрастает, и $x_2$ такое, что в его окрестности f(x) убывает, то можно запустить между ними бинпоиск и найти точку $x_0$ такую, что слева от нее возрастает значение функции, а справа - убывает. Это и есть локальный максимум.

А если функция выпуклая, то она вообще выглядит красиво: сначала возрастает, потом максимум, потом убывает.

Проблема только в одном: как по точке понять, в ее окрестности значение функции убывает или возрастает? Достаточно тыкнуть две точки очень-очень рядом с ней и сравнить их значения!

### Задание

Придумайте, как с помощью вещественного бинпоиска найти

- максимум функции $x - e^x$ (она выпуклая, и максимум ровно один)
- какой-нибудь локальный максимум функции $31x+x^3-x^4$

### Тернарный поиск

Другой способ искать максимум - это тернарный поиск. Пусть известно, что максимум находится между left и right. Поделим отрезок на **три** равные части:

- middle_left = (2 * left + right) / 3
- middle_right = (left + 2 * right) / 3

Тогда если f(middle_left) < f(middle_right), то можно спокойно заменить left на middle_left (максимум точно не левее middle_left), а если f(middle_left) > f(middle_right), то можно спокойно заменить right на middle_right. Он будет работать не за двоичный логарифм, а за логарифм по основанию полтора, что больше (но асимптотически то же самое, так как отличается в константу раз).

Оба способа работают быстро, и обобщаются на дискретный случай (то, что было в начале - когда дан массив, значения в котором сначала возрастают, а потом убывают). Но проблема есть в том, что **если функция нестрого возрастает и нестрого убывает, а именно если там есть отрезки постоянства, то алгоритм не работает**. В случае, когда значения функции равны, никак нельзя понять, с какой стороны искать максимум - он может быть с любой стороны.

### Задание

Решите 4 и 5 задачи в этом контесте:

https://informatics.msk.ru/moodle/mod/statements/view.php?id=33216

### Бинарный поиск по неотсортированному массиву

Заметьте, что в первоначальной задаче условие на то, что сначала идут нули, а потом идут единицы несущественно. Главное, чтобы мы знали индекс, который показывает на 0, и индекс, который показывает на 1. После этого бинарным поиском мы таким же способом найдем пару соседних нуля и единицы в массиве.

Поэтому бинарный поиск работает и не для возрастающих массивов / функций, если наша задача состоит именно в поиске двух соседних индексов, в которых условие выполняется и не выполняется.

Например, если мы знаем, что $f(x_0) < 0$ и $f(x_1) > 0$, и функция непрерывная, то бинарным поиском можно найти ноль этой функции между $x_0$ и $x_1$, даже если функция не монотонная!

Или, например, если нужно в массиве найти соседние четное и нечетное числа, и известно положение какого-то четного числа и какого-то нечетного числа, то это тоже можно легко сделать с помощью бинарного поиска.

Полезно иметь это в виду, это применяется в нескольких задачах контестов.



Пусть дана функция f(x), унимодальная на некотором отрезке [l;r]. Под унимодальностью понимается один из двух вариантов. Первый: функция сначала строго возрастает, потом достигает максимума (в одной точке или целом отрезке), потом строго убывает. Второй вариант, симметричный: функция сначала убывает убывает, достигает минимума, возрастает. В дальнейшем мы будем рассматривать первый вариант, второй будет абсолютно симметричен ему.

Требуется найти максимум функции f(x) на отрезке [l;r].

Алгоритм
Возьмём любые две точки m_1 и m_2 в этом отрезке: l < m_1 < m_2 < r. Посчитаем значения функции f(m_1) и f(m_2). Дальше у нас получается три варианта:

Если окажется, что f(m_1) < f(m_2), то искомый максимум не может находиться в левой части, т.е. в части [l;m_1]. В этом легко убедиться: если в левой точке функция меньше, чем в правой, то либо эти две точки находятся в области "подъёма" функции, либо только левая точка находится там. В любом случае, это означает, что максимум дальше имеет смысл искать только в отрезке [m_1;r].
Если, наоборот, f(m_1) > f(m_2), то ситуация аналогична предыдущей с точностью до симметрии. Теперь искомый максимум не может находиться в правой части, т.е. в части [m_2;r], поэтому переходим к отрезку [l;m_2].
Если f(m_1) = f(m_2), то либо обе эти точки находятся в области максимума, либо левая точка находится в области возрастания, а правая — в области убывания (здесь существенно используется то, что возрастание/убывание строгие). Таким образом, в дальнейшем поиск имеет смысл производить в отрезке [m_1;m_2], но (в целях упрощения кода) этот случай можно отнести к любому из двух предыдущих.
Таким образом, по результату сравнения значений функции в двух внутренних точках мы вместо текущего отрезка поиска [l;r] находим новый отрезок [l^\prime;r^\prime]. Повторим теперь все действия для этого нового отрезка, снова получим новый, строго меньший, отрезок, и т.д.

Рано или поздно длина отрезка станет маленькой, меньшей заранее определённой константы-точности, и процесс можно останавливать. Этот метод численный, поэтому после остановки алгоритма можно приближённо считать, что во всех точках отрезка [l;r] достигается максимум; в качестве ответа можно взять, например, точку l.

Осталось заметить, что мы не накладывали никаких ограничений на выбор точек m_1 и m_2. От этого способа, понятно, будет зависеть скорость сходимости (но и возникающая погрешность). Наиболее распространённый способ — выбирать точки так, чтобы отрезок [l;r] делился ими на 3 равные части:

 m_1 = l + \frac{r-l}{3} 
 m_2 = r - \frac{r-l}{3} 

Впрочем, при другом выборе, когда m_1 и m_2 ближе друг к другу, скорость сходимости несколько увеличится.

Случай целочисленного аргумента
Если аргумент функции f целочисленный, то отрезок [l;r] тоже становится дискретным, однако, поскольку мы не накладывали никаких ограничений на выбор точек m_1 и m_2, то на корректность алгоритма это никак не влияет. Можно по-прежнему выбирать m_1 и m_2 так, чтобы они делили отрезок [l;r] на 3 части, но уже равные только приблизительно.

Второй отличающийся момент — критерий остановки алгоритма. В данном случае тернарный поиск надо будет останавливать, когда станет r-l<3, ведь в таком случае уже невозможно будет выбрать точки m_1 и m_2 так, чтобы были различными и отличались от l и r, и это может привести к зацикливанию. После того, как алгоритм тернарного поиска остановится и станет r-l<3, из оставшихся нескольких точек-кандидатов (l,l+1,\ldots,r) надо выбрать точку с максимальным значением функции.

Реализация
Реализация для непрерывного случая (т.е. функция f имеет вид: \rm double\ f\ (double\ x)):

double l = ..., r = ..., EPS = ...; // входные данные
while (r - l > EPS) {
   double m1 = l + (r - l) / 3,
      m2 = r - (r - l) / 3;
   if (f (m1) < f (m2))
      l = m1;
   else
      r = m2;
}
Здесь \rm EPS — фактически, абсолютная погрешность ответа (не считая погрешностей, связанных с неточным вычислением функции).

Вместо критерия "while (r - l > EPS)" можно выбрать и такой критерий останова:

for (int it=0; it<iterations; ++it)
С одной стороны, придётся подобрать константу \rm iterations, чтобы обеспечить требуемую точность (обычно достаточно нескольких сотен, чтобы достичь максимальной точности). Но зато, с другой стороны, число итераций перестаёт зависеть от абсолютных величин l и r, т.е. мы фактически с помощью \rm iterations задаём требуемую относительную погрешность.

