---
title: Реализация операций «снизу»
weight: 3
draft: true
authors:
- Григорий Горюнов
- "[Александр Бачериков](https://codeforces.com/blog/entry/18051)"
---

Деревья отрезков используются, если есть какой-то массив и требуется обрабатывать некоторые изменения и выполнять запросы на непрерывных отрезках. В первом примере запросы следующие:

1. Изменить элемент массива
2. Найти сумму на отрезке массива

### Полное двоичное дерево

![](../img/segtree-ranges.png)

Запись на картинке имеет вид `node_index: отрезок [L; R)`. На нижней строке массив в 0-индексации --- листья дерева. Предположим, что массив имеет длину степени 2 (к примеру, 16), тогда мы получаем полное двоичное дерево. Значение в вершине $i$ получается комбинированием значений в вершинах $2i$ и $2i+1$. Таким образом, если поступает запрос суммы на полуинтервале `[3; 11)`, необходимо просуммировать значения в вершинах 19, 5, 12 и 26 (отмечены жирным), а не всех 8 листьев, попавших в диапазон. Давайте посмотрим на код, чтобы понять, _почему_ он работает.

```cpp
const int N = 1e5;  // Ограничение на размер
int n;  // истинный размер
int t[2 * N];

void build() {  // Построить дерево отрезков
  for (int i = n - 1; i > 0; --i) t[i] = t[i<<1] + t[i<<1|1];
}

void modify(int p, int value) {  // Присвоить значение в точке
  for (t[p += n] = value; p > 1; p >>= 1) t[p>>1] = t[p] + t[p^1];
}

int query(int l, int r) {  // сумма на полуинтервале [l, r)
  int res = 0;
  for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
    if (l&1) res += t[l++];
    if (r&1) res += t[--r];
  }
  return res;
}

int main() {
  scanf("%d", &n);
  for (int i = 0; i < n; ++i) scanf("%d", t + n + i);
  build();
  modify(0, 1);
  printf("%d\n", query(3, 11));
  return 0;
}
```

**Вот и всё.** Полностью работающий пример. Забудь о рекурсивных функциях от 5 аргументах как страшный сон!

Теперь разберемся почему _это_ вообще работает, и работает эффективно.

1. По картинке видно, что листья хранятся одним сплошным списком начиная с индекса `n`, то есть элемент с номером `i` соответствует вершине с номером `n + i`. Таким образом, можно сразу считывать значения в листья ДО.

2. До обработки запросов необходимо построить дерево. Процедура простая и занимает $O(n)$ времени. Поскольку нидекс родительской вершины меньше индексов дочерних, можно проходить все вершины в порядке уменишения их номера. Если битовые операции для вас --- черная магия, то код в `build()` эквивалентен `t[i] = t[2 * i] + t[2 * i + 1]`.

3. Изменение элемента тоже простое (последующий код позволит убедиться в этом) и время его работы пропорционально высоте дерева, то есть $O(\log n)$. Нужно изменять только значения предков вершины. Таким образом, можно подняться по дереву до корня зная, что предок вершины `p` это `p / 2` (`p >> 1`), а `p ^ 1` меняет `2 * i` на `2 * i + 1` и наоборот, то есть показывает второго сына.

4. Нахождение суммы также работает за $O(\log n)$. Чтобы лучше понять логику работы, можно просто рассмотреть пример `[3; 11)` и проверить, что результат получается из вершин 19, 26, 12, 5 именно в таком порядке.

Основная идея заключена в следующем. Если левая граница запроса нечетна (то есть если `l&1`), то `l` -- правый сын своего родителя. Это значит, что интервал включает `l`, но не включает его родителя. Тогда добавим `t[l]` в ответ и сдвинем границу вбок и вверх (`l = (l + 1) / 2`). Если `l` четно, что это левый сын и интервал включает в себя его родителя (пока конечно правая граница не мешает), так что можно просто перейти к предку (`l = l / 2`). Аналогичные рассуждения можно провести для правой границы. Останавливается алгоритм при совпадении левой и правой границ.

**Никакой рекурсии.** Не нужно вычисять середину интервала. Просто проход по всем затрагиваемым вершинам и ничего лишнего.

### Массив любой длины

Мы считали размер массива степенью 2, пожтому дерево отрезков было полным. Следующий факт может вас шокировать, так что подготовьтесь.

> *Приведенный код работает для массивов любой длины.*

Объяснение этого факта сложнее, чем раньше, так что сначала поймем преимущества этого подхода.

1. ДО использует ровно $2n$ памяти, а не $4n$, как предлагают некоторые реализации (привет, e-maxx!).

2. Элементы массива хранятся сплошным массивом с индекса $n$.

3. Все операции очень эффективны и легко пишутся.

Следующую часть можно пропустить и просто протестировать код, проверив корректность. Но для тех, кому всё-таки нужно объяснение, рассмотрим пример $n = 13$.

![](../img/segtree-ranges2.png)

Теперь дерево отрезков представляет собой не одно полное двоичное дерево, а лес из полных двоичных деревьев: корень 2 высота 4, корень 7 высота 2, корень 13 высота 1. Вершины, отмеченные черточками на картинке вообще никогда не учавствуют в запросах, так что там может быть что угодно. Хоть листья и находятся на разной высоте, это исправимо: режем дерево перед 13-й вершиной и приставляем правую часть слева. Автор оригинала предполагает, что можно показать, что получившаяся структура изоморфна части большего полного двоичного дерева с нашими операциями, и это основная причина работоспособности алгоритма.

Формального доказательства не будет, просто покажем на примере. Рассмотрим интервал `[0; 7)`. Изначально `l = 13, r = 20`, `l&1 => add t[13]` и границы смещаются на `l = 7, r = 10`. Снова `l&1 => add t[7]`, границы смещаются на `l = 4, r = 5`, вершины на одной высоте. Теперь `r&1 => add t[4 = --r]`, границы переходят на `l = r = 2`, алгоритм заканчивается.

### Изменение на отрезке, значение в точке

Некоторым приходят в голову очень сложные идеи, если поменять запросы местами, к примеру

1. Добавить значение ко всем элементам на отрезке

2. Найти значение определенного элемента

Но все, что нужно сделать, это поменять `modify` и `query`:

```cpp
void modify(int l, int r, int value) {
  for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
    if (l&1) t[l++] += value;
    if (r&1) t[--r] += value;
  }
}

int query(int p) {
  int res = 0;
  for (p += n; p > 0; p >>= 1) res += t[p];
  return res;
}
```

Идея этого кода в том, что теперь мы храним изменения между соседними элементами, а не сам массив, поэтому значение элемента это префиксная сумма.

Если надо просмотреть весь массив, то надо пропушить все изменения в листья. Такой код позволит получить все элементы за $O(n)$, а не $O(n\log n)$ так же, как и использование `build` вместо `n` запросов обновления.

```cpp
void push() {
  for (int i = 1; i < n; ++i) {
    t[i<<1] += t[i];
    t[i<<1|1] += t[i];
    t[i] = 0;
  }
}
```

Однако стоит признать, что подобный код работает, только если порядок изменений отдельного элемента не влияет на конечный результат. К примеру, присваивание этому условию не удовлетворяет. Подробнее этот случай будет рассмотрен в разделе "Отложенные операции".

## Некоммутативные комбинаторы

Был рассмотрен очень простой комбинатор -- сложение. Он является коммутативным, то есть обладает переместительным свойством: $a + b = b + a$. То же самое применимо к умножению, $\gcd$, $\min$, $\max$, так что можно просто заменить все вхождения `+` на любую из этих функций и все будет работать. Самое главное, не забыть сменить нейтральный элемент.

Но в реальном мире существуют задачи с неассоциативными комбинаторами, как к примеру [380C Серёжа и скобочки](https://codeforces.com/contest/380/problem/C). К счастью, данная реализация легко поддерживает такое изменение. Определим структуру `S` и функцию-комбинатор `S combine(S, S)` для нее. В `build` просто заменяем `+` на эту функцию. В `modify` требуется соблюдать правильный порядок детей, зная, что у левого сына четный индекс. В ответе на запрос левая граница идет слева направо, а правая --- справа налево, и в коде выглядеть это будет так:

```cpp
void modify(int p, const S& value) {
  for (t[p += n] = value; p >>= 1; ) t[p] = combine(t[p<<1], t[p<<1|1]);
}

S query(int l, int r) {
  S resl, resr;
  for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
    if (l&1) resl = combine(resl, t[l++]);
    if (r&1) resr = combine(t[--r], resr);
  }
  return combine(resl, resr);
}
```

## Отложенные операции

Отложенные операции позволяют отвечать на запросы на отрезках и делать изменения на отрезках. Для начала, введем немного переменных:

```cpp
int h = sizeof(int) * 8 - __builtin_clz(n);  // h = log2(n)
int d[N]; 
```

`h` --- высота дерева, то есть наибольший единичный бит в `n`. `d[i]` это список отложенных операций, которые необходимо протолкнуть в детей вершины `i` при надобности (из примеров станет понятнее). Размер массива только `N`, поскольку у листьев нет детей. Итоговое потребление памяти составляет $3n$.

Ранее было сказано, что `t[i]` соответствует значению функции на своем отрезке. Теперь это не совсем так --- сначала нужно применить все отложенные операции на пути от вершины `i` до корня. Будем предполагать, что `t[i]` уже включает `d[i]`, так что путь начинается не с `i`, а с его непосредственного предка.

Вернемся к примеру с промежутком $[3; 11)$, но теперь нам нужно обновить на нём все элементы. Чтобы это сделать, изменим значения `t[i]` и `d[i]` в вершинах 19, 5, 12 и 26. Далее, если, к примеру, надо получить значение в вершине 22, нам нужно протолкнуть изменения с вершины 5. Заметим также, что операции изменения могут менять значения `t[i]` у своих предков: вершина 19 затрагивает вершины 9, 4, 2 и 1, а вершина 5 -- вершины 2 и 1. Следующий факт критичен для оценки асимптотики:

> Изменения на интервале $[l; r)$ затрагивают значения `t[i]` только у родителей крайних листов (`l+n` и `r+n-1`).

Доказательство простое: при передвижении левой границы вершина, которую мы изменяем в цикле, всегда является правым сыном своего предка. Значит, все предыдущие модификации были сделаны в поддереве левого сына того же предка, иначе мы бы обработали предка, а не обоих его сыновей. Это значит, что текущий непосредственный предок также является одним из предков листа `l+n`. Аналогичные рассуждения для правой границы верны.

Хватит пустых слов, пришло время конкретных примеров с кодом.

### Инкремент на отрезке, запрос максимума

Возможно, это самый простой случай. Представленный ниже код далек от универсальности и не самый эффективный, но с него можно начать.

```cpp
void apply(int p, int value) {
  t[p] += value;
  if (p < n) d[p] += value;
}

void build(int p) {
  while (p > 1) p >>= 1, t[p] = max(t[p<<1], t[p<<1|1]) + d[p];
}

void push(int p) {
  for (int s = h; s > 0; --s) {
    int i = p >> s;
    if (d[i] != 0) {
      apply(i<<1, d[i]);
      apply(i<<1|1, d[i]);
      d[i] = 0;
    }
  }
}

void inc(int l, int r, int value) {
  l += n, r += n;
  int l0 = l, r0 = r;
  for (; l < r; l >>= 1, r >>= 1) {
    if (l&1) apply(l++, value);
    if (r&1) apply(--r, value);
  }
  build(l0);
  build(r0 - 1);
}

int query(int l, int r) {
  l += n, r += n;
  push(l);
  push(r - 1);
  int res = -2e9;  // лучше конечно писать INT_MIN
  for (; l < r; l >>= 1, r >>= 1) {
    if (l&1) res = max(res, t[l++]);
    if (r&1) res = max(t[--r], res);
  }
  return res;
}
```

Проанализируем код по функциям. Первые три являются вспомогательными, о которых вызывающая программа не должна ничего знать.

1. У нас есть два значения для каждой вершины, поэтому хорошо бы написать функцию, применяющую (`apply`) изменения каждой из них. `p < n` значит, что `p` не лист. Важное свойство максимума: если все значения на отрезке увеличить на определенное значение, то и максимум увеличится на это значение.

2. `build` обновляет всех предков вершины.

3. `push` проталкивает изменения из всех предков вершины начиная с корня. Эти предки в являются префиксами двоичной записи числа `p`, поэтому при их расчете используются побитовые сдвиги.

Теперь пришло время посмотерть на основные функции.

1. `inc`: обработаем запрос инкремента знакомым циклом, а затем обновим всё, что осталось вызовами `build`.

2. `query`: Чтобы ответить на запрос, воспользуемся предыдущим циклом, но перед ним необходимо протолкнуть изменения в те вершины, которые мы будем использовать. Также как и в `build`, Достаточно просто протолкнуть изменения от предков в граничные листы.

Легко заметить, что все операции выполняются за время $O(\log n)$.

Этот случай простой, поскольку

1. Порядок изменений не затрагивает их результат (коммутативность комбинатора)

2. При обновлении вершины нет необходимости знать о длине отрезка вершины.

Следующий пример покажет, как это всё учесть.

### Присваивание на отрезке, запрос суммы

Пример вдохновлен задачей [Timus 2042](http://acm.timus.ru/problem.aspx?space=1&num=2042).

И снова начнём со вспомогательных функций.

```cpp
void calc(int p, int k) {
  if (d[p] == 0) t[p] = t[p<<1] + t[p<<1|1];
  else t[p] = d[p] * k;
}

void apply(int p, int value, int k) {
  t[p] = value * k;
  if (p < n) d[p] = value;
}
```

Это просто функции, которые за $O(1)$ вычисляют значение в вершине `p` и применяют к ней отложенные операции. Но кое-что нужно помнить:

1. Предполагается, что существует значение, никогда не используемое для изменения, в нашем случае это 0. Если такого значения не существует, просто сделайте дополнительный bool-массив и пользуйтесь им вместо `d[p] == 0` для проверки наличия изменений.

2. Появился дополнительный параметр `k`, обозначающий длину отрезка вершины. Далее в коде под `k` будет подразумеваться именно это. Очевидно, что нельзя посчитать сумму на отрезке без знания длины этого отрезка. Можно не передавать длину отрезка в функцию, а, к примеру, вычислять его на лету из индекса верштины или вообще сохранить все длины отрезков в специальный массив, но они все затратны по времени или памяти.

Далее потребуется обновить методы `build` и `push`. У нас было две версии этих методов -- одна за $O(n)$ проходит всё дерево, другая за $O(\log n)$ проходит всех предков листа. Эти две функции можно объединить и получить даже больше:

```cpp
void build(int l, int r) {
  int k = 2;
  for (l += n, r += n-1; l > 1; k <<= 1) {
    l >>= 1, r >>= 1;
    for (int i = r; i >= l; --i) calc(i, k);
  }
}

void push(int l, int r) {
  int s = h, k = 1 << (h-1);
  for (l += n, r += n-1; s > 0; --s, k >>= 1)
    for (int i = l >> s; i <= r >> s; ++i) if (d[i] != 0) {
      apply(i<<1, d[i], k);
      apply(i<<1|1, d[i], k);
      d[i] = 0;
    }
}
```

Обе функции работают за $O( \log(n) + |r-l| )$. Если нужно изменить какой-то промежуток на дереве, то можно написать что-то типа

```cpp
push(l, r);
...  // делаем что угодно с элементами из промежутка [l, r)
build(l, r);
```

Как работают эти функции? Сначала исходный промежуток переходит в отрезок $[l+n;r+n-1]$, чтобы можно было верно вычислять предков. Так как они проходят дерево по уровням, то легко поддерживать длину отрезка, которая всегда является степенью 2. `build` проходит снизу вверх, поэтому изначально $k = 2$ (не 1, так как для листьев не надо ничего делать) и удваивается с каждым уровнем. `push` проходит сверху вниз, так что $k = 2^h$ (то есть зависит от высоты дерева) и делится пополам на каждом уровне.

Основные функции из прошлого примера не сильно поменялись, но в `modify`:

1. Необходимо удостовериться, что нет никаких изменений на путях от корня до вершин, которые необходимо обновить, поскольку порядок изменений важен. Это выполняется простым вызовом `push`, как это делалось в `query`.

2. Необходимо поддерживать значение `k`.

```cpp
void modify(int l, int r, int value) {
  if (value == 0) return;
  push(l, l + 1);
  push(r - 1, r);
  int l0 = l, r0 = r, k = 1;
  for (l += n, r += n; l < r; l >>= 1, r >>= 1, k <<= 1) {
    if (l&1) apply(l++, value, k);
    if (r&1) apply(--r, value, k);
  }
  build(l0, l0 + 1);
  build(r0 - 1, r0);
}

int query(int l, int r) {
  push(l, l + 1);
  push(r - 1, r);
  int res = 0;
  for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
    if (l&1) res += t[l++];
    if (r&1) res += t[--r];
  }
  return res;
}
```

Можно заметить неоптимальность кода `modify`: сделано три прохода по вершинам: один проход вниз в `push` и два --- вверх. От последнего прохода вверх можно избавиться, но выглядеть код будет ужасно:

```cpp
void modify(int l, int r, int value) {
  if (value == 0) return;
  push(l, l + 1);
  push(r - 1, r);
  bool cl = false, cr = false;
  int k = 1;
  for (l += n, r += n; l < r; l >>= 1, r >>= 1, k <<= 1) {
    if (cl) calc(l - 1, k);
    if (cr) calc(r, k);
    if (l&1) apply(l++, value, k), cl = true;
    if (r&1) apply(--r, value, k), cr = true;
  }
  for (--l; r > 0; l >>= 1, r >>= 1, k <<= 1) {
    if (cl) calc(l, k);
    if (cr && (!cl || l != r)) calc(r, k);
  }
}
```

Флаги показывают, были ли изменения слева и справа. Посмотрим на пример:

![](../img/segtree-ranges-3.png)

Вызовем `modify` на отрезке $[4; 13)$:

1. `l = 20, r = 29`, вызываем `apply(28)`.
2. `l = 10, r = 14`, вызываем `calc(14)`: первая вершина справа от текущего интервала в точности предок последней измененной.
3. `l = 5, r = 7`, вызываем сначала `calc(7)`, затем `apply(5)` и `apply(6)`.
4. `l = 3, r = 3`, первый цикл закончен.

Теперь понятно, зачем делать `--l`, потому что нам все еще надо обновить вершины 2, 3 и затем 1. Условие выхода `r > 0`, так как после первого цикла можно получить `l = r = 1`, так что придется обновить корень, но `--l` делает `l = 0`.

По сравнению с прошлой версией, убраны ненужные вызовы `calc(10)`, `calc(5)`, но продублировался вызов `calc(1)`.

### Примечания

Все работает корректно, пока вы не пытаетесь получить значения напрямую из дерева, за исключением значений в листьях. Если длина массива не является степенью 2, то получить ответ на всем массиве НЕЛЬЗЯ используюя `t[1]`. НУЖНО вызвать `query(0, n)` для этого!

Также существует [альтернативная](https://codeforces.com/blog/entry/1256) реализация ДО снизу
