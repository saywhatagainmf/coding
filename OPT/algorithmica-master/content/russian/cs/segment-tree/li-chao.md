---
title: Дерево Ли Чао
draft: true
---

Дерево Li Chao --- это структура данных, умеющая обрабатывать два вида
запросов:

  - Добавить линейную функцию $f(x) = ax + b$ в множество $X$.
  - Найти максимальное значение $f(x)$ по всем $f \\in X$ при заданном
    $x$.

#### Структура дерева

Построим дерево, аналогичное [дереву
отрезков](дерево_отрезков "wikilink"), над всем
множеством координат (если координаты вещественные, то над всем
множеством с определенной точностью). В каждой вершине дерева
будем хранить какую-то линейную функцию (изначально нейтральную).

Определим $get$-запросы для координаты $x$ над деревом таким образом:

  - Сделаем спуск по дереву к листу, соответствующему координате $x$
  - Выпишем все посещенные вершины
  - Возьмем максимум среди всех этих функций

Теперь придумаем такие $add$-запросы, что после их выполнения $get$
корректен:

  - Пусть мы хотим добавить функцию $f$
  - Рассмотрим вершину $v$ такую, что <i>вне отрезка</i> $\[l, r\]$,
    соответствующему вершине $v$, $f$ никогда не бывает
    максимальной.
  - Посмотрим на среднюю точку для этого отрезка $m = \\frac{l + r}{2}$
    и на функцию $g$, записанную в $v$.
  - Если $f(m) \> g(m)$, то поменяем $f, g$ местами.
  - Заметим, что теперь функция $f$ может быть максимальной <b>либо</b>
    на $\[l, m - 1\]$, <b>либо</b> на $\[m + 1, r\]$ (если переменные
    вещественные, то $m \\pm \\epsilon$)
  - Рекурсивно решим задачу в соответствующем поддереве

#### Реализация

Очень часто данное дерево надо реализовывать в [неявном
виде](динамические_структуры_данных "wikilink").

``` c++ numberLines

struct line {
    int k = 0, m = 0;
    line() {}
    line(int k, int m): k(k), m(m) {}
    int get(int x) {
        return k * x + m;
    }
};

line t[4 * MAXN];

void upd(int v, int tl, int tr, line L) {
    if (tl > tr) {
        return;
    }
    int tm = (tl + tr) / 2;
    bool l = L.get(tl) > t[v].get(tl);
    bool mid = L.get(tm) > t[v].get(tm);
    if (mid) {
        swap(L, t[v]);
    }
    if (l != mid) {
        upd(2 * v, tl, tm - 1, L);
    }
    else {
        upd(2 * v + 1, tm + 1, tr, L);
    }
}

int get(int v, int tl, int tr, int x) {
    if (tl > tr) {
        return 0;
    }
    int tm = (tl + tr) / 2;
    if (x == tm) {
        return t[v].get(x);
    }
    if (x < tm) {
        return max(t[v].get(x), get(2 * v, tl, tm - 1, x));
    }
    else {
        return max(t[v].get(x), get(2 * v + 1, tm + 1, tr, x));
    }
}
```

[Категория:Конспект](Категория:Конспект "wikilink")
[Категория:Оптимизации
динамики](Категория:Оптимизации_динамики "wikilink")

---


### Дерево Ли Шао

Существует другой подход к Convex Hull Trick: увидеть здесь не точки и оптимизацию скалярного произведения, а линии и нахождение минимума в точке среди этих линий.

![](https://i.imgur.com/TqfVWDD.png)

Применительно к нашей задаче, выражение $\min_k (a_k, b_k) \cdot (1, x_{i-1})$ можно раскрыть как $\min_k (a_k + b_k \cdot x_{i-1})$ и представить как нахождение минимума в точке среди множества прямых вида $y = a_k + b_k \cdot x$.

*Дерево Ли Шао* (англ. *Li Chao segment tree*, кит. *李超段树*) — модификация дерева отрезков над множеством возможных $x$, каждая вершина которого хранит в себе такую прямую, что если пройти по пути от корня до соответствующего листа, то максимум в данной точке будет наибольшее значение на пути.

![](https://raw.githubusercontent.com/e-maxx-eng/e-maxx-eng/mastimg/li_chao_vertex.png)

Пусть в вершину пришло обновление — прямая *new*. Если в ней ничего не хранится, то запишем *new* в вершину и выйдем. Если там уже есть какая-то другая прямая *old*, то одна из них будет «доминировать» над другой хотя бы на одной из половин, а в другой будет либо пересекаться, либо тоже доминировать.

Если одна прямая полностью доминирует над другой, то мы её просто запишем в вершину, а про вторую забудем. Если же прямая доминирует только в одной из половин, то мы запишем её, а «проигравшую» прямую передадим в рекурсию в ту половину, где она может доминировать.

```c++
typedef int ftype;
typedef complex<ftype> point;
#define x real
#define y imag

ftype dot(point a, point b) {
    return (conj(a) * b).x();
}

ftype f(point f, ftype x) {
    return dot(f, {x, 1});
}

const int inf = 1e6 + 42;

point ln[8 * inf];
void add_line(point nw, int v = 1, int l = -inf, int r = inf) {
    point ol = ln[v];
    int m = (l + r) / 2;
    bool lef = f(nw, l) > f(ol, l);
    bool mid = f(nw, m) > f(ol, m);
    ln[v] = mid ? nw : ol;
    if(r - l == 1)
        return;
    if(lef != mid)
        add_line(mid ? ol : nw, 2 * v, l, m);
    else
        add_line(mid ? ol : nw, 2 * v + 1, m, r);
}

int get(int x, int v = 1, int l = -inf, int r = inf) {
    if(r - l == 1)
        return f(ln[v], x);
    int m = (l + r) / 2;
    if(x < m)
        return max(f(ln[v], x), get(x, 2 * v, l, m));
    else
        return max(f(ln[v], x), get(x, 2 * v + 1, m, r));
}
```

Достаточно полезно сравнить между собой CHT и дерево Ли-Шао и понимать, в какой из ситуаций стоит применять каждую из этих структур. Адекватные реализации CHT требуют особых условий — точки должны быть отсортированы по $x$. Если это выполнено, то работать алгоритм будет значительно быстрее, чем дерево Ли Шао, которое, в свою очередь, решает более общую задачу, но работает за $O(\log MAXC)$ на запрос, а зачастую еще и требует неявную реализацию, если $MAXC$ достаточно большое (неявная реализация схожа с [неявным деревом отрезков](segtree)).

---

Рассмотрим следующую задачу:

<i>Вася надувает воздушный шар. Каждую секунду он может либо
дополнительно надуть шар, либо ничего не делать. Если он
надувает шар в $i$-ю секунду, то радиус увеличивается на $a_i$, но
после этого радиус будет уменьшаться на $b_i$ в секунду до следующего
поддува. Найдите максимальный радиус шара, который можно получить за
$n$ секунд.</i>

Данную задачу можно решить с помощью динамического программирования.
$dp_i$ — это наилучший радиус, который можно получить через $i$ секунд.
Тогдв $$dp_i = \\max_{j=1}^{i-1} dp_j + a_j - b_j \\cdot (i - j) =
\\max_{j=1}^{i-1} (-b_j) \\cdot i + (dp_j + a_j + b_j \\cdot j) =
\\max_{j=1}^{i-1} A_j \\cdot i + B_j$$ где $A, B$ зависят только от
$j$. То есть можно считать, что нам надо найти минимальное значение
среди линейных функций в точке $i$.

#### Convex hull

Будем поддерживать структуру данных, которая позволяет:

  - добавить линейную функцию
  - найти максимальное значение в данном множестве функций в точке $x$

Заметим, что данная функция будет иметь вид верхней огибающей.
Пересечение новой линейной функции и огибающей не может имметь
больше двух точек. Тогда нам надо научиться удалить из огибающей все
прямые, которые из нее целиком пропали, а после добавить новую
прямую и точки пересечения.

Такие операции действительно можно делать, если сложить все прямые в
`std::set`, находить [бинпоиском](бинарный_поиск "wikilink") те прямые,
с которыми надо пересечь новую, и удалять все прямые между ними. Это
будет работать за $O(n \\log n)$, но пишется достаточно тяжело, и
нужно редко. Кроме того, такую задачу можно решать, используя
[дерево Li Chao](дерево_Li_Chao "wikilink")

Гораздо чаще в задаче бывает ограничение на монотонное изменение
линейного коэффициента прямых (в нашем случае, $-b_i$). Тогда
прямые нужно добавлять не в произвольное место структуры данных, а
только в конец. В таком случае можно заменить `std::set` на
[стек](стек "wikilink"). Тогда находить точки пересечения можно не
бинпоиском, а постепенным удалением "бесполезных" прямых. Таким образом,
структуру можно реалиизовать с суммарным временем работы $O(n)$, если
запросы по $x$ тоже были отсортированы (если не были, то отвечать на
запрос бы будем за $O(\\log n)$.

#### Реализация

В раиках данной реализации мы храним две величины: массив прямых $lines$
и массив точек изменений $pr$. Считаем, что $lines_i$ является
минимальной на промежутке $\[pr_i, pr_{i + 1}\]$.

``` c++ numberLines
struct Line {
    int k, m;
};

vector<int> pr; // если округлять точку пересечения вниз, то можно хранить их в целых числах
vector<Line> lines;

int get(int x) {
    int l = 0;
    int r = lines.size();
    while (l + 1 < r) {
        int mid = (l + r) / 2;
        if (pr[mid] <= x) {
            l = mid;
        }
        else {
            r = mid;
        }
    }
    return lines[l].k * x + lines[l].m;
}

void upd(Line line) {
    while (lines.size() && line.k * pr.back() + line.m < lines.back().k * pr.back() + lines.back().m) {
        pr.pop_back();
        lines.pop_back();
    }
    int coord;
    if (lines.empty()) {
        coord = -INF;
    } else {
        coord = cross(line, lines.back()); // нужно реализовать пересечение прямых
    }
    pr.push_back(coord);
    lines.push_back(line);
}
```

[Категория:Конспект](Категория:Конспект "wikilink")
[Категория:Оптимизации
динамики](Категория:Оптимизации_динамики "wikilink")
