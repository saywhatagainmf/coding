---
title: Разновидности задачи RMQ
weight: 5
draft: true
---

Если нужно поддерживать запросы изменения и минимума на отрезке (*dynamic RMQ*), то самым простым решением является дерево отрезков или любое другое бинарное дерево. Оно будет работать за $O(n)

Если массив дан заранее и запросов изменения нет (*static RMQ*), то ещё более удобной 

Также есть менее практичный алгоритм Фараха-Колтона и Бендера, сводящий.



Строго рекомендуется сначала прочитать про [RMQ в
окне](RMQ_в_окне "wikilink").

## От RMQ в окне к RMQ-offline

Раньше, решая задачу про RMQ в окне, мы хранили окно, в котором элементы
были расположены по убыванию. Мы пользовались тем, что при добавлении
элемента у нас двигается правая граница, а при удалении --- левая.

Теперь же сделаем сканлайн по правым границам. При их сдвиге элемент
точно так же будет добавляться. К сожалению, у нас нарушилось
условие на удаление при сдвиге $l$, потому что левые границы
теперь двигаются в обе стороны.

## СНМ

Тем не менее, мы все еще будем хранить элементы по убыванию в нашей
структуре, но просто не будем делать никаких удалений. Вместо этого
мы мысленно присоединим левую границу запроса к первому элементу справа
от него. Этот элемент, очевидно, будет являться максимумом на текущем
суффиксе массива --- от границы $l$ до границы $r$.

Таким образом, мы получаем следующие требования к структуре:

  - Добавление элемента.
  - Поддерживание убывающей последовательности как в [RMQ в
    окне](RMQ_в_окне "wikilink").
  - Нахождение первого элемента справа, находящегося в
    последовательности.

Заметим, что при добавлении элемента он всегда оказывается в
последовательности. Возможно, он рушит какие-то другие
элементы. Тогда все индексы, которые раньше относились к этим
элементам, теперь относятся к новому элементу. Это значит, что
происходит слияние множеств. Такое слияние можно поддерживать с
помощью [СНМ](СНМ "wikilink"), если внутри множества хранить еще и
максимум в множестве.

---

Предварительно рекомендуется разобраться в задаче $RMQ$.

## Постановка задачи

Дана задача $RMQ$ с ограничением на запросы:

$$l_i \\le l_{i + 1}, r_i \\le r_{i + 1}$$

Это значит, что при упорядочивании запросов по правой границе, они
окажутся также упорядочены и по левой.

## Решение задачи за $O(n)$

Будем идти по запросам в порядке сортировки и поддерживать элементы в
окне. Заметим, что если элемент сейчас является максимальным в
очереди, то все элементы левее него уже никогда не станут
оптимальным ответом --- ведь они раньше удалятся из очереди.
Значит, можно хранить не всю очередь, а только ее убывающую
последовательность из суффиксных максимумов.

Как ее поддерживать? При сдвиге левой границы у нас иногда просто
удалится один элемент. При сдвиге правой границы у нас добавится
элемент, который может сломать условие суффиксного максимума для всех
чисел, меньших его. Это какой-то суффикс очереди. Тогда мы честно его
удалим и потом добавим элемент.

Поддерживать очередь можно с помощью [deque](deque "wikilink"), а
работает алгоритм за $O(n)$ амортизированно, потому что каждый
элемент добавится один раз и удалится один раз.

[Категория:Конспекты](Категория:Конспекты "wikilink")
