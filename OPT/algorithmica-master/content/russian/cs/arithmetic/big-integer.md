---
title: Длинная арифметика
authors:
- Максим Иванов
weight: 5
draft: true
---


Того что тут написано вроде больше нигде нет на русском. Скорее всего
это нифига не понятно, но раз уж у меня был конспект по этому, то я
залью его сюда.

Нам понадобится [Быстрое преобразование
Фурье](Быстрое_преобразование_Фурье "wikilink")
чтобы иметь умножение за $O(n \\log n)$.

## Быстрое деление двух чисел

У нас будут 2 функции, рекурсивно вызывающие друг друга. $n$ всегда
будет являться точной степенью двух, $|a|$ будет обозначать длину
числа a.

1.  div21 — делит число $a$ длиной не более $2n$ на число $b$ длиной не
    более $n$, при условии, что ответ по длине не превосходит $n$.
2.  div32 — делит число $a$ длиной не более $3n$ на число $b$ длиной не
    более $2n$, при условии, что ответ по длине не превосходит $n$.

Обе функции должны возвращать результат деления и остаток.

### div21

Как работает div21: пусть $m=\\frac{n}{2}$. Тогда $a$ имеет длину не
более $4m$, на $b$ имеет длину не более $2m$, а ответ по длине не
превосходит $2m$. Возьмём первые $|a| - m \\le 3m$ цифр числа $a$ и
разделим на число $b$ при помощи div32. Ответ по длине не превзойдёт
$m$, так как иначе $a/b$ было бы больше по длине чем $2m$. Далее возьмём
остаток после этого деления, домножим его на $10^m$, и припишем к нему
последние $m$ цифр числа $a$. После этого разделим это число на $b$.
Так как $|b| \\le 2m$, то длина остатка не превосходит $2m$, значит
длина остатка, домноженного на $10^m$ на превосходит $m$, тогда для
деления мы можем использовать функцию div32. Далее умножим результат
первого деления на $m$ и прибавил результат второго деления. Так мы
получим ответ.

### div32

Как работает div32: пусть $|b| \\le n$. Тогда так как длина ответа не
превосходит $n$, $|a| \\le 2n$, тогда будем использовать $div21$.
Иначе возьмём $b_1$, образованное первыми $n$ цифрами из $b$.
Возьмём $a_1$, образованное первыми $|a| - (|b| - n)$ цифрами из
$a$. (Т.е. обрежем $a$ и $b$ на одинаковое число цифр в конце так, чтобы
длина $b$ стала равна $n$) Обозначим за $k = |b| - n$. (т.е. сколько
цифр в конце мы отрезали от $a$ и от $b$). Обозначим за $r_a = a -
a_1 \\cdot 10^k$, $r_b = b - b_1 \\cdot 10^k$. (т.е. обозначим за
$r_a$ и $r_b$ то, что мы отрезали от $a$ и от $b$). Тогда $a / b =
(a_1 \\cdot 10^k + r_a) / (b_1 \\cdot 10^k + r_b)$.

Сразу за этим утверждением следует следующее утверждение.

Тогда $a_1 / b_1 \\ge a / b \\ge a_1 / (b_1 + 1)$. Теперь возьмём $q
= a_1 / b_1$ и будем пытаться получить из него $a / b$. Несложно
заметить, что на самом деле $q \\ge a / b \\ge q - 10$. Для этого
надо показать, что:

Тогда $a_1 / b_1 \\ge a / b \\ge a_1 / b_1 - 10$. Тогда для div32
получается следующий алгоритм. Строим числа $a_1$ и $b_1$. С
помощью div21 разделим $a_1$ на $b_1$. (Если $a_1 \> b_1
\\cdot 10^n$, будем считать что результат равен $10^n - 1$). Далее
вычтем из $a$ результат деления, домноженный на $b$ и посчитаем
остаток от текущего деления. Пока остаток меньше нуля, будем
прибавлять к нему $b$ и вычитать из частного 1. Таких действий
мы сделаем не более $n$.

При совсем маленьких числах надо делить уже используя int-овое деление.

Можно увеличить базу с 10 до $10^9$, но делать это надо аккуратно.

Асимптотику доказать несложно. $div21(n)$ делает $O(n)$ действий и
вызывает div32 два раза. $div32(n)$ делает $O(n \\log n)$ действий
(т.к. там есть операция умножения) и возможно вызывает $div21(n)$. Таким
образом $div21(n)$ делает $O(n \\log n)$ действий и два раза вызывает
div21. Таким образом время работы $O(n \\log^2 n)$.

Более подробное описание и доказательство этого алгоритма можно найти по
[ссылке](http://cr.yp.to/bib/1998/burnikel.ps)

## Быстрый корень произвольной степени

### Метод Ньютона

Для начала рассмотрим алгоритм поиска корня $k$ степени за
$O(n\\log^3n)$ с огромной константой. Будем использовать Ньютоновский
метод поиска нуля функции $f(x)$. Он работает итерациями\~--- есть
начальное число $x_0$. Далее
$x_{n+1}=x_n-\\frac{f(x_n)}{f'(x_n)}$. Каждая следующая итерация
приближает $x_n$ к нулю функции.

Тогда если мы возьмём функцию $f(x)=a-x^k$, то максимальный целый $x$,
при котором функция положительна и есть корень $k$ степени из $a$.
Тогда $f'(x) = -k\\cdot x^{k - 1}$. Тогда $$x_{n + 1} = x_n +
\\frac{a}{k \\cdot x_n^{k - 1}} - \\frac{x_n}{k}$$ Тогда если за
$x_0$ взять $10^{n/k}$, то кол-во итераций будет $O(\\log n)$ с большой
константой, а в каждой производится операция деления, т.е. асимптотика —
$O(nlog^3n)$.

### Более быстрый алгоритм

То был общеизвестный алгоритм поиска корня который везде используется.
Он не самый быстрый. А теперь будет описан другой алгоритм, который
работает за $O(nlog^2n+klog^3k)$ c малой константой. Будем искать
корень $k$ степени из $x$ рекурсивно. Но сначала чуть чуть
математики. Если вы не хотите разбираться в этом говне, а
хотите сразу алгоритм, то он написан ниже.

Пусть $\\sqrt\[k\]{x} = a10^m+b$, где $b \< 10^m$. Тогда

$$x=a^k10^{km}+ka^{k-1}b10^{(k-1)m}+\\frac{k(k-1)}{2}a^{k-2}b^2
10^{(k-2)m}+...+b^k$$

Тогда если $a \> b$ и $10^m \> k$ то

$$\\frac{k(k-1)}{2}a^{k-2}b^{2}10^{(k-2)m} \>
\\frac{k(k-1)(k-2)}{1\\cdot2\\cdot3}a^{k-3}b^{3}10^{(k-3)m} \> ... \>
b^k$$

Тогда

$$k\\left(\\frac{k(k-1)}{2}a^{k-2}b^{2}10^{(k-2)m} \\right)\>
\\frac{k(k-1)}{2}a^{k-2}b^{2}10^{(k-2)m} +
\\frac{k(k-1)(k-2)}{1\\cdot2\\cdot3}a^{k-3}b^{3}10^{(k-3)m} + ... +
b^k$$

Тогда если $b\<10^m \<a$ и $10^m\>k^2$ то

$$a^{k-1}\\cdot10^{(k-1)m}\>
k\\left(\\frac{k(k-1)}{2}a^{k-2}b^{2}10^{(k-2)m} \\right)\>
\\frac{k(k-1)}{2}a^{k-2}b^{2}10^{(k-2)m} +
\\frac{k(k-1)(k-2)}{1\\cdot2\\cdot3}a^{k-3}b^{3}10^{(k-3)m} + ... +
b^k$$

А из этого следует уже не такой ужасный алгоритм.

Пусть $n$ - длина числа $x$, из которого мы ищем корень. Пусть
$m=\\frac{n-1}{2k}$. Тогда если $10^m\\leq k^2$, то ищем корень методом
Ньютона. Иначе возьмём число $x$ без последних $km$ цифр. Пусть $a$ -
корень из этого числа. Тогда замечаем, что $\\sqrt\[k\]{x}$ имеет вид
$a10^m+b$, где $b \< 10^m$. При этом $b\<10^m \<a$ и $10^m\>k^2$. Тогда
верно последнее большое неравенство, описанное выше. Тогда
$b=(x-a^k10^{km})/(a^{k-1}10^{(k-1)m})$ или на единицу меньше. Тогда
совершив такое деление и проверив, надо ли вычесть 1 из $b$ мы
найдём $\\sqrt\[k\]{x}$. Замечаем, что самое большое по
асимптотике действие, которое мы сделаем — деление, а далее
вызовемся от числа, в 2 раза меньшего нас по длине. Тогда так как в
конце нам ещё придётся искать корень методом Ньютона из числа, по
длине примерно равному $k$, то всего асимптотика —
$O(nlog^2n+klog^3k)$.

---

Длинная арифметика — это набор программных средств (структуры данных и алгоритмы), которые позволяют работать с числами гораздо больших величин, чем это позволяют стандартные типы данных.

Виды целочисленной длинной арифметики
Вообще говоря, даже только в олимпиадных задачах набор средств достаточно велик, поэтому произведём классификацию различных видов длинной арифметики.

Классическая длинная арифметика
Основная идея заключается в том, что число хранится в виде массива его цифр.

Цифры могут использоваться из той или иной системы счисления, обычно применяются десятичная система счисления и её степени (десять тысяч, миллиард), либо двоичная система счисления.

Операции над числами в этом виде длинной арифметики производятся с помощью "школьных" алгоритмов сложения, вычитания, умножения, деления столбиком. Впрочем, к ним также применимы алгоритмы быстрого умножения: Быстрое преобразование Фурье и Алгоритм Карацубы.

Здесь описана работа только с неотрицательными длинными числами. Для поддержки отрицательных чисел необходимо ввести и поддерживать дополнительный флаг "отрицательности" числа, либо же работать в дополняющих кодах.

Структура данных
Хранить длинные числа будем в виде вектора чисел int, где каждый элемент — это одна цифра числа.

typedef vector<int> lnum;
Для повышения эффективности будем работать в системе по основанию миллиард, т.е. каждый элемент вектора lnum содержит не одну, а сразу 9 цифр:

const int base = 1000*1000*1000;
Цифры будут храниться в векторе в таком порядке, что сначала идут наименее значимые цифры (т.е. единицы, десятки, сотни, и т.д.).

Кроме того, все операции будут реализованы таким образом, что после выполнения любой из них лидирующие нули (т.е. лишние нули в начале числа) отсутствуют (разумеется, в предположении, что перед каждой операцией лидирующие нули также отсутствуют). Следует отметить, что в представленной реализации для числа ноль корректно поддерживаются сразу два представления: пустой вектор цифр, и вектор цифр, содержащий единственный элемент — ноль.

Вывод
Самое простое — это вывод длинного числа.

Сначала мы просто выводим самый последний элемент вектора (или 0, если вектор пустой), а затем выводим все оставшиеся элементы вектора, дополняя их нулями до 9 символов:

printf ("%d", a.empty() ? 0 : a.back());
for (int i=(int)a.size()-2; i>=0; --i)
	printf ("%09d", a[i]);
(здесь небольшой тонкий момент: нужно не забыть записать приведение типа (int), поскольку в противном случае число a.size() будут беззнаковым, и если a.size() \le 1, то при вычитании произойдёт переполнение)

Чтение
Считываем строку в string, и затем преобразовываем её в вектор:

for (int i=(int)s.length(); i>0; i-=9)
	if (i < 9)
		a.push_back (atoi (s.substr (0, i).c_str()));
	else
		a.push_back (atoi (s.substr (i-9, 9).c_str()));
Если использовать вместо string массив char'ов, то код получится ещё компактнее:

for (int i=(int)strlen(s); i>0; i-=9) {
	s[i] = 0;
	a.push_back (atoi (i>=9 ? s+i-9 : s));
}
Если во входном числе уже могут быть лидирующие нули, то их после чтения можно удалить таким образом:

while (a.size() > 1 && a.back() == 0)
	a.pop_back();
Сложение
Прибавляет к числу a число b и сохраняет результат в a:

int carry = 0;
for (size_t i=0; i<max(a.size(),b.size()) || carry; ++i) {
	if (i == a.size())
		a.push_back (0);
	a[i] += carry + (i < b.size() ? b[i] : 0);
	carry = a[i] >= base;
	if (carry)  a[i] -= base;
}
Вычитание
Отнимает от числа a число b (a \ge b) и сохраняет результат в a:

int carry = 0;
for (size_t i=0; i<b.size() || carry; ++i) {
	a[i] -= carry + (i < b.size() ? b[i] : 0);
	carry = a[i] < 0;
	if (carry)  a[i] += base;
}
while (a.size() > 1 && a.back() == 0)
	a.pop_back();
Здесь мы после выполнения вычитания удаляем лидирующие нули, чтобы поддерживать предикат о том, что таковые отсутствуют.

Умножение длинного на короткое
Умножает длинное a на короткое b (b < {\rm base}) и сохраняет результат в a:

int carry = 0;
for (size_t i=0; i<a.size() || carry; ++i) {
	if (i == a.size())
		a.push_back (0);
	long long cur = carry + a[i] * 1ll * b;
	a[i] = int (cur % base);
	carry = int (cur / base);
}
while (a.size() > 1 && a.back() == 0)
	a.pop_back();
Здесь мы после выполнения деления удаляем лидирующие нули, чтобы поддерживать предикат о том, что таковые отсутствуют.

(Примечание: способ дополнительной оптимизации. Если скорость работы чрезвычайно важна, то можно попробовать заменить два деления одним: посчитать только целую часть от деления (в коде это переменная carry), а затем уже посчитать по ней остаток от деления (с помощью одной операции умножения). Как правило, этот приём позволяет ускорить код, хотя и не очень значительно.)

Умножение двух длинных чисел
Умножает a на b и результат сохраняет в c:

lnum c (a.size()+b.size());
for (size_t i=0; i<a.size(); ++i)
	for (int j=0, carry=0; j<(int)b.size() || carry; ++j) {
		long long cur = c[i+j] + a[i] * 1ll * (j < (int)b.size() ? b[j] : 0) + carry;
		c[i+j] = int (cur % base);
		carry = int (cur / base);
	}
while (c.size() > 1 && c.back() == 0)
	c.pop_back();
Деление длинного на короткое
Делит длинное a на короткое b (b < {\rm base}), частное сохраняет в a, остаток в carry:

int carry = 0;
for (int i=(int)a.size()-1; i>=0; --i) {
	long long cur = a[i] + carry * 1ll * base;
	a[i] = int (cur / b);
	carry = int (cur % b);
}
while (a.size() > 1 && a.back() == 0)
	a.pop_back();
Длинная арифметика в факторизованном виде
Здесь идея заключается в том, чтобы хранить не само число, а его факторизацию, т.е. степени каждого входящего в него простого.

Этот метод также весьма прост для реализации, и в нём очень легко производить операции умножения и деления, однако невозможно произвести сложение или вычитание. С другой стороны, этот метод значительно экономит память в сравнении с "классическим" подходом, и позволяет производить умножение и деление значительно (асимптотически) быстрее.

Этот метод часто применяется, когда необходимо производить деление по непростому модулю: тогда достаточно хранить число в виде степеней по простым делителям этого модуля, и ещё одного числа — остатка по этому же модулю.

Длинная арифметика по системе простых модулей (Китайская теорема или схема Гарнера)
Суть в том, что выбирается некоторая система модулей (обычно небольших, помещающихся в стандартные типы данных), и число хранится в виде вектора из остатков от его деления на каждый из этих модулей.

Как утверждает Китайская теорема об остатках, этого достаточно, чтобы однозначно хранить любое число в диапазоне от 0 до произведения этих модулей минус один. При этом имеется Алгоритм Гарнера, который позволяет произвести это восстановление из модульного вида в обычную, "классическую", форму числа.

Таким образом, этот метод позволяет экономить память по сравнению с "классической" длинной арифметикой (хотя в некоторых случаях не столь радикально, как метод факторизации). Крому того, в модульном виде можно очень быстро производить сложения, вычитания и умножения, — все за асимптотически однаковое время, пропорциональное количеству модулей системы.

Однако всё это даётся ценой весьма трудоёмкого перевода числа из этого модульного вида в обычный вид, для чего, помимо немалых временных затрат, потребуется также реализация "классической" длинной арифметики с умножением.

Помимо этого, производить деление чисел в таком представлении по системе простых модулей не представляется возможным.

Виды дробной длинной арифметики
Операции над дробными числами встречаются в олимпиадных задачах гораздо реже, и работать с огромными дробными числами значительно сложнее, поэтому в олимпиадах встречается только специфическое подмножество дробной длинной арифметики.

Длинная арифметика в несократимых дробях
Число представляется в виде несократимой дроби \frac{a}{b}, где a и b — целые числа. Тогда все операции над дробными числами нетрудно свести к операциям над числителями и знаменателями этих дробей.

Обычно при этом для хранения числителя и знаменателя приходится также использовать длинную арифметику, но, впрочем, самый простой её вид — "классическая" длинная арифметика, хотя иногда оказывается достаточно встроенного 64-битного числового типа.

Выделение позиции плавающей точки в отдельный тип
Иногда в задаче требуется производить расчёты с очень большими либо очень маленькими числами, но при этом не допускать их переполнения. Встроенный 8-10-байтовый тип double, как известно, допускает значения экспоненты в диапазоне [-308; 308], чего иногда может оказаться недостаточно.

Приём, собственно, очень простой — вводится ещё одна целочисленная переменная, отвечающая за экспоненту, а после выполнения каждой операции дробное число "нормализуется", т.е. возвращается в отрезок [0.1; 1), путём увеличения или уменьшения экспоненты.

При перемножении или делении двух таких чисел надо соответственно сложить либо вычесть их экспоненты. При сложении или вычитании перед выполнением этой операции числа следует привести к одной экспоненте, для чего одно из них домножается на 10 в степени разности экспонент.

Наконец, понятно, что не обязательно выбирать 10 в качестве основания экспоненты. Исходя из устройства встроенных типов с плавающей точкой, самым выгодным представляется класть основание равным 2.
