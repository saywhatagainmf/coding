---
title: Стек
weight: 5
created: "2018"
date: 2021-08-22
authors:
- Андрей Гаркавый
- Сергей Слотин
draft: true
---

Поверх списков или динамических массивов можно сделать структуры с более конкретной функциональностью, разной в зависимости от алгоритма.

Стек — структура данных, которая хранит элементы и умеет отвечать на две
операции за $O(1)$:

- `push(x)`: положить элемент x в конец стека.
- `top()`: вернуть элемент, лежащий в конце стека.
- `pop()`: снять элемент, лежащий в конце стека.

Подобный принцип добавления и удаления данных называется FILO (first in, last out): последним удаляется тот элемент, который мы положили первым, если сначала положить все элементы, а потом все вынуть.

В С++ стек уже реализован как `stack<T> stack_name`. Помимо `push` и `pop`, у него есть ещё вспомогательные операции:

- `size()`: вернуть размер стека.
- `empty()`: проверка на пустоту.
- `clear()`: очистить стек.

Стек можно реализовать как с помощью списка, так и с помощью динамического массива — в C++ для этого используется `vector`, поэтому амортизировано все операции выполняются за быструю константу, но может потребоваться примерно в два раза больше памяти, чем нужно на хранение самих элементов.

### Скобочные последовательности

*Правильной скобочной последовательностью* называется строка из открывающих и закрывающих скобок, которая может получиться из корректного арифметического выражения удалением всего, кроме скобок.

Например, из выражения $(1 + 2) \cdot (3 + 100 \cdot (3 / 2))$ получается ПСП
`()(())`, а вот `)(())` получить из какого-либо арифметического выражения нельзя.

В правильной скобочной последовательности все скобки можно разделить на пары, где первая скобка — открывающая, вторая — закрывающая, открывающая идет раньше закрывающей, и никакие две пары не пересекаются.

Назовём *балансом* для префикса длины $n$ разницу числа открывающих и закрывающих скобок на этом префиксе. Чтобы понять, является ли скобочная последовательность правильной, достаточно проверить два условия:

1. Баланс всей строки равен 0.
2. Баланс на любом префикса неотрицателен.

То есть на любом префиксе открывающих скобок не меньше, чем закрывающих,
а во всей строке их равное число. Это легко проверить, если проходиться по последовательности слева направо и прибавлять $+1$, если встретим открывающую скобку, и $-1$, если встретим закрывающую скобку. Достаточно проверить, что
баланс всегда был неотрицателен и в конце стал равен нулю.

```cpp
bool is_correct(string s) {
    int bal = 0;
    for (char c : s) {
        if (c == '(')
            bal++;
        else
            bal--;
        if (bal < 0)
            return false;
    }
    return (bal == 0);
}
```

Еще можно определить правильные скобочные последовательности с разными видами скобок, добавив в формальное определение, что скобки в каждой паре должны быть одного вида.

Например, `([]({}))` — это ПСП, а `[(])` — нет.

Проверка правильности через баланс, к несчастью, так легко не обобщается. Решать задачу нужно более прямолинейно — для каждой скобки найдём её вторую половину.

Заведем пустой стек, пройдёмся с ним слева направо и будем класть в конец стека каждую встреченную открывающую скобку и вынимать открывающую скобку из конца стека, когда встречаем любую закрывающую — и при этом будем проверять, что вынимаемая открытая скобка того же типа, что и встреченная закрывающая. Если при построении стека не возникло ошибок, а в конце стек пустой, то последовательность корректная.

Пример: строка `{[([])()]{}}`. В ходе алгоритма стек будет меняться так:

1. стек пустой
2. `{`
3. `{[`
4. `{[(`
5. `{[([`
6. `{[(`: убранная `[` подходит `]`
7. `{[`: убранная `(` подходит `)`
8. `{[(`
9. `{[`: убранная `(` подходит `)`
10. `{`: убранная `[` подходит `]`
11. `{{`
12. `{`: убранная `{` подходит `}`
13. стек пустой: убранная `{` подходит `}`

Все убранные скобки подошли встреченным закрытым, а в конце стек пустой — значит это ПСП.

А вот строка `[{]}` — это не ПСП:

1. стек пустой
2. `[`
3. `[{`
4. ошибка, так как `{` в конце стека не подходит `]`

Реализация:

```cpp
bool is_opening(char c) {
    return c == '(' || c == '[' || c == '{';
}

bool is_matching(char a, char b) {
    return (a == '(' && b == ')') ||
           (a == '[' && b == ']') ||
           (a == '{' && b == '}');
}

bool is_correct(string s) {
    stack<char> t;
    for (char c : s) {
        if (is_opening(c))
            stack.push(c);
        else {
            if (stack.empty() || is_matching(stack.top(), c))
                return false;
            stack.pop();
        }
    }
    return stack.empty();
}
```

Алгоритм работает за $O(n)$, так как мы просто проходимся по строке и каждый раз делаем одну из операций со стеком — либо `push`, либо `pop`.

### Обратная польская запись

Стек также часто используют для вычислений в каком-нибудь сложном порядке. Например, интересно, как именно компьютер вычисляет выражение $(1 + 2) \* (100 \* (3 / 2) + 3) + 4$. Его вычислять сложно, давайте перепишем его в другом формате, в котором его
вычислять проще:

$\[1, 2, +, 100, 3, 2, /, \*, 3, +, \*, 4, +\]$

Такой список чисел и операций называют *обратной польской записью*. Она вычисляется так: нужно проходить слева направо и

- Если встречается число, кладем его в стек.
- Если встречается операция, снимаем с конца стека два числа, применяем к ним эту операцию, и кладем результат в стек.

Например для этого выражения стек будет вести себя так:

  - \[\]
  - $\[1\]$
  - $\[1, 2\]$
  - $\[3\]$
  - $\[3, 100\]$
  - $\[3, 100, 3\]$
  - $\[3, 100, 3, 2\]$
  - $\[3, 100, 1.5\]$
  - $\[3, 150\]$
  - $\[3, 150, 3\]$
  - $\[3, 153\]$
  - $\[459\]$
  - $\[459, 4\]$
  - $\[463\]$

Единственный элемент, оставшийся в конце в стеке — это и есть результат.

### Задача о наибольшем прямоугольнике

У вас есть гистограмма — набор прямоугольников шириной $1$ и высотой до $n$, идущих слева направо вплотную, причем их нижняя $y$-координата всегда равна $0$.

Пример гистограммы:

| | | | | | | | | | |
|-|-|-|-|-|-|-|-|-|-|
| | | | |■| | | | | |
| | | | |■| | | |■| |
| | | | |■| | |■|■| |
| | | | |■| | |■|■|■|
| | | | |■| |■|■|■|■|
| | |■| |■| |■|■|■|■|
| | |■|■|■| |■|■|■|■|
| | |■|■|■|■|■|■|■|■|
| |■|■|■|■|■|■|■|■|■|
|■|■|■|■|■|■|■|■|■|■|

Задача — найти наибольший по площади прямоугольник, лежащий внутри такой клеточной гистограммы.

**Решение.**
Заметим, что нижняя граница наибольшего прямоугольника - это всегда $y = 0$. Наибольший прямоугольник должно быть невозможно расширить ни в одну из сторон. Давайте просто переберем все такие прямоугольники и выберем из них максимальный по площади.

Давайте идти слева направо по вертикальным прямоугольникам гистограммы и хранить такую "лесенку" - в стеке будут лежать пройденные столбики (индекс и высота), но только те, которые нужны, чтобы столбцы строго возрастали, и при этом лесенка заканчивалась последним рассмотренным столбцом.

Строить её нужно так: давайте рассмотрим новый столбец. Если его высота больше, чем у последнего в стеке (предыдущего столбца), то просто кладём его в стек, и на этом всё. Если его высота меньше или равна, чем у последнего, то нужно вынимать столбцы с конца стека, пока высота нового столбца не будет наконец больше, чем у последнего в стеке. В конце нужно просто вынуть все столбцы из стека (для этого удобно просто в конец положить фиктивный столбец высоты ноль).

При вынимании столбца из стека нужно посчитать площадь максимального прямоугольника, который включает этот столбец. Высоту мы уже знаем, надо определить его площадь. Заметим, что его левая координата - это индекс столбца, который лежит перед этим столбцом в стеке (это самый правый столбец, который левее удаляемого и при этом ниже по высоте) плюс один. А правая координата - это та, которую мы сейчас рассматриваем (раз нам нужно удалить этот столбец).

Как это работает? Наибольший прямоугольник упирается верхом хотя бы в один столбец, а значит когда мы его будем удалять, мы учтем этот прямоугольник.

Так можно за $O(N)$ найти площадь максимального прямоугольника в такой гистограмме.

Заметим, что к этой задаче можно свести задачу поиска максимального белого прямоугольника в прямоугольнике с черными и белыми прямоугольниками - нужно для каждой клетки посчитать, сколько клеток подряд наверх из нее - это белые клетки (с помощью простого динамического программирования), и после этого перебрать $N$ строк и решить задачу для гистограммы, низ которой является этой строкой - все высоты как раз мы теперь знаем.

Так мы решим эту задачу за $O(N^2)$ - а это размер прямоугольника, так что быстрее и не получится.
