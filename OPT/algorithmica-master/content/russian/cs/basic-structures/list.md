---
title: Списки
weight: 4
draft: true
---

Связный список (англ. *linked list*) — структура данных, которая поддерживает быструю вставку и удаление элементов из любой позиции, но не обязательно быстрый произвольный доступ к ним.

![](../img/linked.png)

С помощью связных списков можно реализовать другие структуры данных, например [стек](stack) и [очередь](queue).

## Реализация

Связный список обычно реализован в виде набора узлов (англ. *node*), в которых помимо непосредственно элементов хранятся ссылки на узлы, соответствующие следующему и опционально предыдущему элементу списка.

```cpp
template <typename T>
struct Node {
    T val;
    Node *prev, *next;
};

Node *head = 0;
```

### Вставка

```cpp
void insert(Node x) {
    // TODO
}
```

### Удаление

### Поиск

### Xor-list

В некоторых случаях использование двусвязного списка в явном виде является нецелесообразным. В целях экономии памяти можно хранить только результат выполнения операции `xor` над адресами предыдущего и следующего элементов списка. Таким образом, зная адрес предыдущего элемента, мы можем вычислить адрес следующего элемента.

## C++

В STL двусвязный список реализован в `std::list`.

```cpp
// пустой двусвязный список, хранящий элементы типа int
list<int> l;

// вставка после итератора it переменной x
l.insert(it, x);

// удаляет элемент, на который указывает итератор
l.erase(it);

// начало и конец name
l.front(), l.back();
```

Задача о среднем элементе.


## Односвязные и двусвязные списки

Осторожно: эти списки никак не связаны со списками из питона (которые на
самом деле динамические массивы).

Проблема стека: нельзя добавлять и удалять элементы в середине.

Давайте хранить массив $values$ с нужными нам элементами, и для каждого
элемента еще хранить (в структуре или в отдельном массиве $next$)
индекс следующего элемента. И, конечно, хранить индекс самого
первого элемента $start$. Будем называть такую структуру данных
односвязным списком.

Чтобы пройтись по всему односвязному списку, нужно начать с индекса
первого элемента и постепенно переходить по индексу следующего
элемента ($i$ -\> $next\[i\]$), пока $next\[i\] \\neq i$.

Тогда если у нас есть индекс какого-то элемента $index$, мы за $O(1)$
можем вставить после него еще один - нужно добавить в массив справа
еще один элемент, пусть он получил индекс $new$, и сделать
$next\[new\] = next\[index\], next\[index\] = new$.

Часто бывает удобно хранить еще предыдущий элемент помимо следующего,
чтобы можно было проходить по списку справа налево, и добавлять
элемент перед каким-нибудь. Такой список называется двусвязным.