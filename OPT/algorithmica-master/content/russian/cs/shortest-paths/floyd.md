---
title: Алгоритм Флойда
weight: 4
draft: true
---

Мы с вами уже знаем динамическое программирование, давайте рассмотри следующую динамику:

$d_{i j}^k$ - это длина кратчайшего пути от вершины $i$ до $j$, используя как промежуточные только вершины из первых $k$ = $d_{i j}^k$ (напоминает рюкзак).

База динамики ($k = 0$) определяется только путями из одного ребра. Если есть ребро из $i$ в $j$ стоимостью $c$, то $d_{i j}^{0}$ = $c$. Если таких ребер несколько, то, конечно, надо взять минимум.

 Если мы хотим посчитать $d_{i j}^{k}$, то у нас есть два варианта
 
 1) Не брать на пути нигде $k$-ую вершину, тогда $d_{i j}^{k}$ = $d_{i j}^{k - 1}$
 
 2) Взять где-нибудь в пути k-ую вершину, тогда путь разбивается на две части - от $i$ до $k$ и от $k$ до $j$, раз итоговый путь кратчайший, то и и эти два пути должны быть кратчайшми, а значит формула $d_{i j}^{k}$ = $d_{i k}^{k - 1}$ + $d_{k j}^{k - 1}$
 
 В результате ответ - $d_{A B}^{n}$,
 
 Можете подумать, как по такой динамике восстановить сам путь.
 
 Также заметим, что вместо трехмерной динамики в этом алгоритме можно использовать двухмерную, храня в $dp_{ij}$ последнее известное значение из $dp_{ij}^0$, $dp_{ij}^1$ $dp_{ij}^2$, $\ldots$, $dp_{ij}^n$.


```
for(int k = 0; k < n; k++){
    for(int i = 0; i < n; i++){
        for(int j = 0; j < n; j++){
            a[i][j] = min(a[i][j], a[i][k] + a[k][j]);
        }
    }
}
```

### Теоретическое задание

Подумайте, как находить циклы отрицательного веса с помощью Флойда.

Плюсы алгоритма в том, что он находит расстояние сразу от всех вершин графа до остальных, а минус - алгоритм работает за $O(N^3)$;

### Практическое задание

Первые две задачи на алгоритм Флойда.

# Алгоритм Дейкстры

Для этого алгоритма придется рассматривать только графы без отрицательных рёбер.

Алгоритм Дейкстры решает немного другую задачу: он находит расстояние от **одной** вершины $A$ до **каждой** вершины. Давайте для каждой вершины хранить расстояние до нее из вершины $A$ в массиве $d$. Например:
* $d[A] = 0$
* $d[x] = \infty$, если x не достижима из A

Назовем **релаксацией** обновление ответа для вершины $b$ через ребро $(a, b, c)$ таким способом: $d[b] = \min(d[b], d[a] + c)$.

* При таком действии ответ не может стать лучше, чем кратчайшее расстояние до $b$, так как мы просто пользуемся путем для вершины $a$ и продлеваем его в $b$.
* Если мы прорелаксировали все ребра в кратчайшем пути в правильном порядке до вершины $b$, то мы получим кратчайший путь до $b$.

Теперь давайте каждый раз доставать вершину, для которой расстояние от А сейчас минимально, и мы еще ее не смотрели и затем обновлять всех ее соседей. Допустим вершина с минимальным расстоянием - x, тогда надо прорелаксировать все ребра из нее.  

Давайте докажем корректность алгоритма по индукции:

База) Первой вершиной мы всегда рассмотрим $A$, но для нее верно, что расстояние от $А$ до $А$ = 0;

Шаг) Мы достали вершину $i$, нам известно, что для всех ее предков ответ - корректен, но тогда, допустим, что для $i$-ой вершины мы нашли ответ больший, чем надо, тогда это значит, что мы должны прийти из еще не рассмотренной вершины, но так как ребер отрицательного веса в графе нет, то такое невозможно $\Rightarrow$ мы доказали

https://visualgo.net/en/sssp?slide=1

Есть две возможные реализации алгоритма

1) реализация помощью нахождения минимального расстояния внутри массива за линию. Так как мы для каждого шага находим минимальную вершину, то мы сделаем не более $N$ шагов, но при этом на каждом шаге мы находим минимум за линию, то есть алгоритм работает за $O(N^2)$.


```
for (int i = 0; i < n; ++i){
    int uk = -1;
    for (int j = 0; j < n; j++){
        if ((mark[j] == 0) && ((uk == -1) || (d[j] < d[uk]))){
                uk = j;
        }
    }
    for (int j = 0; j < n; j++){
        if ((j != uk) && (g[uk][j] != -1)) d[j] = min(d[j], g[uk][j] + d[uk]);
    }
    mark[uk] = 1;
}
```

2) Реализация за $O(MlognN + NlogN)$ с помощью нахождения минимального расстояния внутри кучи/сета за логарифм. Так как для каждой вершины мы сделаем не более одного извлекания из структуры + каждое ребро мы используем максимум два раза. Для этого давайте в выбранной структуре хранить пару (расстояние, вершина); Первый код реализован с set, второй с кучей. Так как в куче нет компаратора на возрастание, то надо либо сделать свой, либо домножить расстояние на -1;


```
while (used.size()) {
    int v = (*(used.begin())).second;
    for (int i = 0; i < g[v].size(); i++) {
        int to = g[v][i].first, c = g[v][i].second;
        if (dist[v] + c < dist[to]) {
            used.erase({dist[to], to});
            dist[to] = dist[v] + to;
            used.insert({dist[to], to});
        }
    }
    used.erase({dist[v], v});
}
```


```
while (!q.empty()) {
		int v = q.top().second;
		q.pop();
    for (int j = 0; j < g[v].size(); ++j) {
        int to = g[v][j].first, c = g[v][j].second;
        if (d[v] + c < d[to]) {
            d[to] = d[v] + c;
            q.push({-d[to], to});
        }
    }
}
```

### Из асимптотики понятно, что при большом количестве ребер первый алгоритм писать лучше, иначе второй.

### Теоретическое задание

Приведите примеры, когда каждый из алгоритмов работает лучше.

Недостаток алгоритма Дейкстры всего один - он не работает, если в графе есть ребра отрицательного веса.

### Практическое задание

3-5 Задача на алгоритм Дейкстры.

# Форд-Беллман

Этот алгоритм решает ту же задачу, что и Дейкстра, но зато может работать с отрицательными ребрами!

Давайте заведем массив расстояний, как и в дейкстре, для стартовой вершины расстояние = 0. Алгоритм состоит в **релаксации каждого ребра в графе** $N-1$ раз.

Это работает потому, что в кратчайшем пути не больше, чем $N-1$ ребро, и если мы прорелаксируем их в таком порядке, этот путь найдется. После $N-1$ прохода по всем ребрам и их релаксации мы точно это сделаем и найдем кратчайший путь.

Также в этом случае удобнее хранить **список ребер** явно вместо списка смежности.




```
int from[m], to[m], cost[m];
for (int i = 0; i < n - 1; ++i) {
		for (int j = 0; j < m; ++j) {
				d[to[j]] = min(d[to[j]], d[from[j]] + cost[j]);
    }
}
```

### Теоретическое задание

Подумайте, как найти цикл отрицательного веса с помощью этого алгоритма.

### Практическое задание

Решите задачи 6 и 7.

# Ссылка на контест

https://informatics.msk.ru/mod/statements/view.php?id=33380#1

---

# Алгоритм Флойда

## Постановка

Алгоритм Флойда(-Уоршелла) ищет попарные кратчайшие пути в графе $G =
(V, E)$ без отрицательных циклов. В случае наличия в графе отрицательных
циклов, алгоритм может вернуть один из них.

## Решение с помощью динамического программирования

Пусть все вершины в графе пронумерованы от $1$ до $n$, а вес ребра между
вершинами $i$ и $j$ равен $w(i, j)$.

### Определение

Введём динамическое программирование $sp\[i\]\[j\]\[k\]$ --- длина
кратчайшего пути в графе между вершинами $i$, и $j$, при условии,
что все **промежуточные** вершины имеют номера, не превосходящие $k$.
Обратите внимание, что на $i$ и $j$ это ограничение не
распространяется.

### База

$ \\begin{equation}

` sp[i][j][0]=\begin{cases}`
`   w(i, j), & \text{если $(i, j) \in E$}.\\`
`   0, & \text{иначе}.`
` \end{cases}`

\\end{equation} $

### Пересчёт

На $k$-м уровне динамического программирования, мы разрешаем путям между
вершинами посещать вершину с номером $k$. От этого пути между какими-то
$i$ и $j$ могли сократиться за счёт прохода по пути $i \~- k$, а затем
по $k \~- j$.

Таким образом, формула пересчёта устроена следующим образом ($k \\geq
1$): $ \\begin{equation}

` sp[i][j][k]=min\begin{cases}`
`   sp[i][j][k - 1]\\`
`   sp[i][k][k - 1] + sp[k][j][k - 1]`
` \end{cases}`

\\end{equation} $

### Where is <s>the money</s> the answer, Lebowsky?

Кратчайшее расстояние между вершинами $i$ и $j$ находится в
$sp\[i\]\[j\]\[n\]$.

### Восстановление ответа

Если нам нужно дополнительно восстанавливать ответ, то надо по ходу
алгоритма для каждой пары $i$ и $j$ запоминать, через какую вершину
$k$ мы в последний раз улучшили ответ. Затем, в конце, чтобы
восстановить путь между $i$ и $j$, надо рекурсивно
восстановить путь между $i$ и $k$ (не включительно), затем
рекурсивно восстановить путь между $k$ и $j$, а затем вывести $j$.

## Уменьшаем затраты памяти

Обратим внимание на то, что в динамическом программировании нам в каждый
момент требуется хранить только предыдущий $k-1$-й слой, поэтому можно
сократить затраты памяти в $n$ раз, убрав последнее измерение.

Если же вовсе убрать последнее измерение из всех формул, то теперь на
$k$-м шаге динамическое программирование для какой-то пары вершин может
учитывать уже обновлённое значение, и тем самым посчитать значение с
$k+1$-го или больше уровня динамики. Но если нам важно лишь получить
кратчайшие расстояния в конце, то этот спецэффект не является
проблемой и после $n$ шагов мы всё равно получим кратчайшие
расстояния, просто, возможно, они посчитаются пораньше.

## А что с отрицательными циклами?

### Теорема

В графе есть отрицательный цикл $\\iff$ после $n$ внешних итераций
алгоритма на главной диагонали стоит отрицательное число. Более
того, все вершины $i$, для которых $sp\[i\]\[i\] \< 0$ лежат на
каком-то цикле отрицательного веса.

### Доказательство

#### $\\impliedby$

Если на главной диагонали в какой-то момент оказалось отрицательное
число, значит в какой-то момент было верно, что $sp\[i\]\[k\] +
sp\[k\]\[j\] \< 0$, что в точности означает, что цикл $ i \~- k \~- i$
имеет отрицательный вес.

#### $\\implies$

Пусть в графе есть отрицательный цикл $C$. Возьмём какую-нибудь вершину
$i$ из него. Пусть $k$ --- наибольший номер среди вершин из $C$ кроме
$i$. Если таких нет, то $C$ --- петля отрицательного веса и на главной
диагонали изначально стоит отрицательное число.

Заметим, что на $k$-й итерации алгоритма для $sp\[i\]\[i\]$ будет в том
числе рассматриваться значение $sp\[i\]\[k\] + sp\[k\]\[i\]$. Причём
$sp\[i\]\[k\] \\leq |C\[i:k\]| \\land sp\[k\]\[i\] \\leq |C\[k:i\]|
\\implies sp\[i\]\[k\] + sp\[k\]\[i\] \\leq |C| \< 0 \\implies $ на
$k$-й итерации в $sp\[i\]\[i\]$ будет стоять отрицательное число, а
значит после всех итераций и подавно. $C\[i:k\]$ --- часть цикла $C$
между вершинами $i$ и $k$ при каком-то фиксированном обходе. $C\[k:i\]$
--- оставшаяся часть цикла.

### Вывод отрицательного цикла

Алгоритм очень простой

1.  Найти $i$ такую что $sp\[i\]\[i\] \< 0$
2.  Запустить алгоритм восстановления кратчайшего пути из $i$ в $i$.

Заметим, что мы выводим лишь какой-то цикл отрицательного веса. В худшем
случае их может быть порядка $n\!$. Упражнение: в каком графе?
