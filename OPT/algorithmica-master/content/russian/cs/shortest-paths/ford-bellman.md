---
title: Алгоритм Форда-Беллмана
authors:
- Максим Иванов
weight: 5
draft: true
---

Пусть дан ориентированный взвешенный граф G с n вершинами и m рёбрами, и указана некоторая вершина v. Требуется найти длины кратчайших путей от вершины v до всех остальных вершин.

В отличие от алгоритма Дейкстры, этот алгоритм применим также и к графам, содержащим рёбра отрицательного веса. Впрочем, если граф содержит отрицательный цикл, то, понятно, кратчайшего пути до некоторых вершин может не существовать (по причине того, что вес кратчайшего пути должен быть равен минус бесконечности); впрочем, этот алгоритм можно модифицировать, чтобы он сигнализировал о наличии цикла отрицательного веса, или даже выводил сам этот цикл.

Алгоритм носит имя двух американских учёных: Ричарда Беллмана (Richard Bellman) и Лестера Форда (Lester Ford). Форд фактически изобрёл этот алгоритм в 1956 г. при изучении другой математической задачи, подзадача которой свелась к поиску кратчайшего пути в графе, и Форд дал набросок решающего эту задачу алгоритма. Беллман в 1958 г. опубликовал статью, посвящённую конкретно задаче нахождения кратчайшего пути, и в этой статье он чётко сформулировал алгоритм в том виде, в котором он известен нам сейчас.

Описание алгоритма
Мы считаем, что граф не содержит цикла отрицательного веса. Случай наличия отрицательного цикла будет рассмотрен ниже в отдельном разделе.

Заведём массив расстояний d[0 \ldots n-1], который после отработки алгоритма будет содержать ответ на задачу. В начале работы мы заполняем его следующим образом: d[v] = 0, а все остальные элементы d[] равны бесконечности \infty.

Сам алгоритм Форда-Беллмана представляет из себя несколько фаз. На каждой фазе просматриваются все рёбра графа, и алгоритм пытается произвести релаксацию (relax, ослабление) вдоль каждого ребра (a,b) стоимости c. Релаксация вдоль ребра — это попытка улучшить значение d[b] значением d[a] + c. Фактически это значит, что мы пытаемся улучшить ответ для вершины b, пользуясь ребром (a,b) и текущим ответом для вершины a.

Утверждается, что достаточно n-1 фазы алгоритма, чтобы корректно посчитать длины всех кратчайших путей в графе (повторимся, мы считаем, что циклы отрицательного веса отсутствуют). Для недостижимых вершин расстояние d[] останется равным бесконечности \infty.

Реализация
Для алгоритма Форда-Беллмана, в отличие от многих других графовых алгоритмов, более удобно представлять граф в виде одного списка всех рёбер (а не n списков рёбер — рёбер из каждой вершины). В приведённой реализации заводится структура данных \rm edge для ребра. Входными данными для алгоритма являются числа n, m, список e рёбер, и номер стартовой вершины v. Все номера вершин нумеруются с 0 по n-1.

Простейшая реализация
Константа \rm INF обозначает число "бесконечность" — её надо подобрать таким образом, чтобы она заведомо превосходила все возможные длины путей.

struct edge {
	int a, b, cost;
};
 
int n, m, v;
vector<edge> e;
const int INF = 1000000000;
 
void solve() {
	vector<int> d (n, INF);
	d[v] = 0;
	for (int i=0; i<n-1; ++i)
		for (int j=0; j<m; ++j)
			if (d[e[j].a] < INF)
				d[e[j].b] = min (d[e[j].b], d[e[j].a] + e[j].cost);
	// вывод d, например, на экран
}
Проверка "if (d[e[j].a] < INF)" нужна, только если граф содержит рёбра отрицательного веса: без такой проверки бы происходили релаксации из вершин, до которых пути ещё не нашли, и появлялись бы некорректные расстояния вида \infty - 1, \infty - 2, и т.д.

Улучшенная реализация
Этот алгоритм можно несколько ускорить: зачастую ответ находится уже за несколько фаз, а оставшиеся фазы никакой полезной работы не происходит, лишь впустую просматриваются все рёбра. Поэтому будем хранить флаг того, изменилось что-то на текущей фазе или нет, и если на какой-то фазе ничего не произошло, то алгоритм можно останавливать. (Эта оптимизация не улучшает асимптотику, т.е. на некоторых графах по-прежнему будут нужны все n-1 фаза, но значительно ускоряет поведение алгоритма "в среднем", т.е. на случайных графах.)

С такой оптимизацией становится вообще ненужным ограничивать вручную число фаз алгоритма числом n-1 — он сам остановится через нужное число фаз.

void solve() {
	vector<int> d (n, INF);
	d[v] = 0;
	for (;;) {
		bool any = false;
		for (int j=0; j<m; ++j)
			if (d[e[j].a] < INF)
				if (d[e[j].b] > d[e[j].a] + e[j].cost) {
					d[e[j].b] = d[e[j].a] + e[j].cost;
					any = true;
				}
		if (!any)  break;
	}
	// вывод d, например, на экран
}
Восстановление путей
Рассмотрим теперь, как можно модифицировать алгоритм Форда-Беллмана так, чтобы он не только находил длины кратчайших путей, но и позволял восстанавливать сами кратчайшие пути.

Для этого заведём ещё один массив p[0 \ldots n-1], в котором для каждой вершины будем хранить её "предка", т.е. предпоследнюю вершину в кратчайшем пути, ведущем в неё. В самом деле, кратчайший путь до какой-то вершины a является кратчайшим путём до какой-то вершины p[a], к которому приписали в конец вершину a.

Заметим, что алгоритм Форда-Беллмана работает по такой же логике: он, предполагая, что кратчайшее расстояние до одной вершины уже посчитано, пытается улучшить кратчайшее расстояние до другой вершины. Следовательно, в момент улучшения нам надо просто запоминать в p[], из какой вершины это улучшение произошло.

Приведём реализацию Форда-Беллмана с восстановлением пути до какой-то заданной вершины t:

void solve() {
	vector<int> d (n, INF);
	d[v] = 0;
	vector<int> p (n, -1);
	for (;;) {
		bool any = false;
		for (int j=0; j<m; ++j)
			if (d[e[j].a] < INF)
				if (d[e[j].b] > d[e[j].a] + e[j].cost) {
					d[e[j].b] = d[e[j].a] + e[j].cost;
					p[e[j].b] = e[j].a;
					any = true;
				}
		if (!any)  break;
	}
 
	if (d[t] == INF)
		cout << "No path from " << v << " to " << t << ".";
	else {
		vector<int> path;
		for (int cur=t; cur!=-1; cur=p[cur])
			path.push_back (cur);
		reverse (path.begin(), path.end());
 
		cout << "Path from " << v << " to " << t << ": ";
		for (size_t i=0; i<path.size(); ++i)
			cout << path[i] << ' ';
	}
}
Здесь мы сначала проходимся по предкам, начиная с вершины t, и сохраняем весь пройденный путь в списке \rm path. В этом списке получается кратчайший путь от v до t, но в обратном порядке, поэтому мы вызываем \rm reverse от него и затем выводим.

Доказательство алгоритма
Во-первых, сразу заметим, что для недостижимых из v вершин алгоритм отработает корректно: для них метка d[] так и останется равной бесконечности (т.к. алгоритм Форда-Беллмана найдёт какие-то пути до всех достижимых из s вершин, а релаксация во всех остальных вершинах не произойдёт ни разу).

Докажем теперь следующее утверждение: после выполнения i фаз алгоритм Форда-Беллмана корректно находит все кратчайшие пути, длина которых (по числу рёбер) не превосходит i.

Иными словами, для любой вершины a обозначим через k число рёбер в кратчайшем пути до неё (если таких путей несколько, можно взять любой). Тогда это утверждение говорит о том, что после k фаз этот кратчайший путь будет найден гарантированно.

Доказательство. Рассмотрим произвольную вершину a, до которой существует путь из стартовой вершины v, и рассмотрим кратчайший путь до неё: (p_0=v, p_1, \ldots, p_k=a). Перед первой фазой кратчайший путь до вершины p_0=v найден корректно. Во время первой фазы ребро (p_0,p_1) было просмотрено алгоритмом Форда-Беллмана, следовательно, расстояние до вершины p_1 было корректно посчитано после первой фазы. Повторяя эти утверждения k раз, получаем, что после k-й фазы расстояние до вершины p_k=a посчитано корректно, что и требовалось доказать.

Последнее, что надо заметить — это то, что любой кратчайший путь не может иметь более n-1 ребра. Следовательно, алгоритму достаточно произвести только n-1 фазу. После этого ни одна релаксация гарантированно не может завершиться улучшением расстояния до какой-то вершины.

Случай отрицательного цикла
Выше мы везде считали, что отрицательного цикла в графе нет (уточним, нас интересует отрицательный цикл, достижимый из стартовой вершины v, а недостижимые циклы ничего в вышеописанном алгоритме не меняют). При его наличии возникают дополнительные сложности, связанные с тем, что расстояния до всех вершин на этом цикле, а также расстояния до достижимых из этого цикла вершин не определены — они должны быть равны минус бесконечности.

Нетрудно понять, что алгоритм Форда-Беллмана сможет бесконечно делать релаксации среди всех вершин этого цикла и вершин, достижимых из него. Следовательно, если не ограничивать число фаз числом n-1, то алгоритм будет работать бесконечно, постоянно улучшая расстояния до этих вершин.

Отсюда мы получаем критерий наличия достижимого цикла отрицательного веса: если после n-1 фазы мы выполним ещё одну фазу, и на ней произойдёт хотя бы одна релаксация, то граф содержит цикл отрицательного веса, достижимый из v; в противном случае, такого цикла нет.

Более того, если такой цикл обнаружился, то алгоритм Форда-Беллмана можно модифицировать таким образом, чтобы он выводил сам этот цикл в виде последовательности вершин, входящих в него. Для этого достаточно запомнить номер вершины x, в которой произошла релаксация на n-ой фазе. Эта вершина будет либо лежать на цикле отрицательного веса, либо она достижима из него. Чтобы получить вершину, которая гарантированно лежит на цикле, достаточно, например, n раз пройти по предкам, начиная от вершины x. Получив номер y вершины, лежащей на цикле, надо пройтись от этой вершины по предкам, пока мы не вернёмся в эту же вершину y (а это обязательно произойдёт, потому что релаксации в цикле отрицательного веса происходят по кругу).

Реализация:

void solve() {
	vector<int> d (n, INF);
	d[v] = 0;
	vector<int> p (n, -1);
	int x;
	for (int i=0; i<n; ++i) {
		x = -1;
		for (int j=0; j<m; ++j)
			if (d[e[j].a] < INF)
				if (d[e[j].b] > d[e[j].a] + e[j].cost) {
					d[e[j].b] = max (-INF, d[e[j].a] + e[j].cost);
					p[e[j].b] = e[j].a;
					x = e[j].b;
				}
	}
 
	if (x == -1)
		cout << "No negative cycle from " << v;
	else {
		int y = x;
		for (int i=0; i<n; ++i)
			y = p[y];
 
		vector<int> path;
		for (int cur=y; ; cur=p[cur]) {
			path.push_back (cur);
			if (cur == y && path.size() > 1)  break;
		}
		reverse (path.begin(), path.end());
 
		cout << "Negative cycle: ";
		for (size_t i=0; i<path.size(); ++i)
			cout << path[i] << ' ';
	}
}
Поскольку при наличии отрицательного цикла за n итераций алгоритма расстояния могли уйти далеко в минус (по всей видимости, до отрицательных чисел порядка -2^n), в коде приняты дополнительные меры против такого целочисленного переполнения:

d[e[j].b] = max (-INF, d[e[j].a] + e[j].cost);
В приведённой выше реализации ищется отрицательный цикл, достижимый из некоторой стартовой вершины v; однако алгоритм можно модифицировать, чтобы он искал просто любой отрицательный цикл в графе. Для этого надо положить все расстояния d[i] равными нулю, а не бесконечности — так, как будто бы мы ищем кратчайший путь изо всех вершин одновременно; на корректность обнаружения отрицательного цикла это не повлияет.

Дополнительно на тему этой задачи — см. отдельную статью "Поиск отрицательного цикла в графе".

---

### Задача

Дан ориентированный граф $G=(V, E)$ с выделенной вершиной $s$. Веса
рёбер в графе могут быть любыми. Надо для каждой вершины найти
кратчайшее расстояние до неё от $s$.

#### Ориентированность

Ориентированность графа важна, потому что поиск кратчайших путей в
неориентированном графе с отрицательными весами рёбер не решается
с помощью алгоритма Форда-Беллмана. Но можно свести к поиску
паросочетания минимальной стоимости в графе (необязательно
двудольном). [Подробнее можно почитать
тут](https://vk.com/away.php?to=http%3A%2F%2Facm.math.spbu.ru%2F%7Esk1%2Fdownload%2Fpapers%2Fshort_path.pdf&post=5333_4200&cc_key=)

### Динамическое программирование

Решим эту задачу с помощью динамического программирования:

  - $sp\[k\]\[v\]$ - кратчайшее растояние от $s$ до $v$ по путям, в
    которых $k$ рёбер.
  - Начальные значения
      - $ sp\[0\]\[s\] = 0 $
      - $ sp\[0\]\[V \\setminus \\{s\\} \] = INF $
      - $ sp\[1...|V|\]\[\*\] = INF $
  - $ sp\[k\]\[v\] = \\min_{u \\in N(v)} sp\[k-1\]\[u\] + w(u, v) $
  - Порядок пересчёта:

<!-- end list -->

``` C++

for (int k = 0; k < vertices_count; ++k) {
  for (int v = 0; v < vertices_count; ++v) {
    // ...
  }
}
```

  - Ответ: $dist\[v\] = \\min_{k} sp\[k\]\[v\]$
  - Восстановление ответа: либо запоминаем для каждого состояния, из
    какого пришли, либо заново перебираем

### Переходим от вершин к рёбрам

Заметим, что цикл по вершинам, внутри которого перебираются соседи,
можно заменить на цикл по рёбрам и получить

``` C++

void relax(int& old_value, int new_value) {
  old_value = min(old_value, new_value);
}

// Инициализация динамики
for (int k = 0; k < vertices_count; ++k) {
  for (auto&& [from, to, w] : edges) {
    relax(sp[k][to], sp[k-1][from] + w);
  }
}
```

### Избавляемся от одного из измерений

Мы получили решение, в котором используется массив размера $|V| \\times
|V|$. Мы можем изменить это и получить 2 массива длины $|V|$ -
достаточно заметить, что для подсчёта $sp\[k\]\[\*\]$
достаточно знать $sp\[k-1\]\[\*\]$, поэтому нам достаточно
хранить только 2 последних слоя динамики.

### Оставляем только один массив

В предыдущем пункте можно отказаться от двух массивов и оставить только
$sp\[v\]$. Тогда $sp\[v\] = \\min_{u \\in N(v)} sp\[u\] + w(u, v)$.
Однако, теперь значение, хранящееся в $sp\[v\]$ потеряет то
значение, которое мы ему придавали раньше, потому что теперь при
пересчёте слоя динамики мы можем воспользоваться значениями из нового
слоя.

Однако можно доказать, что за $k$ итераций в $sp\[v\]$ будут точно
рассмотрены пути длины хотя бы $k$ рёбер от $s$ до $v$ (плюс,
возможно, пути большей длины) (доказательство по индукции,
упражнение читателю). Из этого следует, что за $|V| - 1$
итераций в $sp\[v\]$ будут рассмотрены все возможные пути из $s$
в $v$ $\\implies$ в $sp\[v\]$ будут будет хранится кратчайшее
расстояние от $s$ до $v$.

### Ускоряем алгоритм (Алгоритм SPFA)

Заметим следующее:

1.  Если на какой-то итерации внешнего цикла $sp\[\*\]$ не изменился, то
    мы уже нашли все кратчайшие расстояния и можно прекратить наш
    алгоритм.
2.  Достаточно на каждом шаге рассматривать не все рёбра, а только те, у
    которых $sp$ изменился хотя бы для одного из концов.

Эти немудрёные рассуждения приводят нас к следующему, окончательному
коду:

``` C++

typedef int Vertex;
typedef long long dist_t;

bool try_relax(dist_t& old_value, dist_t new_value) {
  old_value = min(old_value, new_value);
  return old_value == new_value;
}

vector<dist_t> SPFA(int start) {
  vector<dist_t> sp(n, INF);
  sp[start] = 0;

  vector<Vertex> updated_vertices = { start };

  for (int k = 0; k < vertices_count; ++k) {
    vector<Vertex> newly_updated_vertices;

    for (auto& v : updated_vertices) {
      for (auto&& [to, w] : edge_from[v]) {
        if (try_relax(sp[to], sp[v] + w)) {
          newly_updated_vertices.push_back(to);
        }
      }
    }

    if (newly_updated_vertices.empty()) {
      break;
    }

    updated_vertices.swap(newly_updated_vertices);
  }

 return sp;
}
```

## Форд-Беллман с random_shuffle

Если вы вдруг забыли про SPFA, то вы всё ещё можете ускорить ваш
алгоритм Форда-Беллмана, случайным образом перемешивая рёбра.
Подробнее: <http://codeforces.com/blog/entry/58825>

## Поиск циклов отрицательного веса

### Теорема

В графе есть цикл отрицательного веса, достижимый из $s$ $\\iff$ после
$|V|$-й итерации алгоритма $updated \\_ vertices$ непусто.

Доказательство:

$\\implies$: пусть в графе есть отрицательный цикл $v_0 \\rightarrow
v_1 \\rightarrow \\dots \\rightarrow v_k = v_0$. Если в этом цикле
есть такое ребро $v_i \\rightarrow v_{i+1}$, что на $|V|$-м шаге
$sp\[v_{i+1}\] \> sp\[v_{i}\] + w(v_{i}, v_{i+1})$, то $v_{i+1}$
окажется в $updated\\_ vertices$ и утверждение доказано. Пусть
такого ребра нет, то есть $$ \\forall i \\in \[0 \\dots k\]:
sp\[v_{i+1}\] \\leq sp\[v_{i}\] + w(v_{i}, v_{i+1}) $$

Сложим эти неравенства и заметим, что $\\sum_{0 \\leq i \\leq k-1}
sp\[v_{i+1}\] = \\sum_{0 \\leq i \\leq k-1} sp\[v_{i}\]$ (поскольку
это одна и та же сумма, в которой сделали циклический сдвиг (помним,
что $v_k = v_0$)).

Значит, если сократить, получится: $$ 0 \\leq \\sum_{0 \\leq i \\leq
k-1} w(v_{i}, v_{i+1}) $$

Или, другими словами, наш цикл вовсе не имеет отрицательный вес.
Противоречие.

$\\impliedby$: если на $|V|$-й итерации расстояние до какой-то вершины
уменьшилось, значит существует последовательность из хотя бы $|V|$
рёбер из $s$ в некоторую вершину $v$, вдоль которой расстояние
меньше, чем то, что было на $(|V| - 1)$-й итерации. Поскольку
рёбер не меньше, чем $|V|$, то в этой последовательности есть цикл.
Если этот цикл имеет неотрицательный вес, то его можно выкинуть из
последовательности и получить последовательность рёбер меньшей
длины, которая должна была быть рассмотрена на предыдущих шагах
алгоритма $\\implies$ на $|V|$-й итерации расстояние не могло
уменьшиться вдоль последовательности с циклом. Значит, цикл
всё-таки имеет отрицательный вес, а это ровно то, чего мы хотели.
∎

Из леммы следует, что для проверки наличия цикла отрицательного веса
достаточно запустить алгоритм на ещё одну итерацию и проверить, что
ничего не изменилось.

### Восстановление цикла отрицательного веса

Чтобы восстановить цикл достаточно для каждой вершины $v$ запоминать
$prev\[v\]$ - вершину, через которую произошла последняя релаксация
ребра в $v$. Тогда для восстановления цикла отрицательного веса
достаточно взять любое из рёбер, которые прорелаксировались на
$|V|$-м шаге и начать от них разматывать цикл.

Корректность этого алгоритма следует из того, что любое ребро, которое
прорелаксировалось на $|V|$-м шаге лежит на цикле отрицательного веса
$\\implies$ пойдя из конца ребра мы вернёмся в него, пройдя по нашему
циклу отрицательного веса.