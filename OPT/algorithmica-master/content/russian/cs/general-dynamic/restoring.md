---
title: Восстановление ответа
weight: 5
draft: true
---


### Восстановление ответа

Часто в задачах надо не только найти наибольшее или наименьшее значение
чего-либо, но и сказать, как его получить. В задаче про кузнечика надо
восстановить последовательность точек, по которым пропрыгает кузнечик.
Рассмотрим два способа:

<strong>Запоминание ответа</strong>

Запомним в отдельный массив ту клетку, из который оптимальнее всего
прыгнуть в текущую. Делаем это непосредственно при подсчете
динамики. Массив $prev$ содержит лучшего предка.

``` C++ numberLines
vector<int> dp(n, 0);
for (int i = 1; i < n; i++) {
    for (int j = max(0, i - 3): j < i; j++) {
        if (dp[i] < dp[j] + c[i]) {
            prev[i] = j;
            dp[i] = dp[j] + c[i];
        }
    }
}
```

Затем надо пройтись от точки $n-1$ до нуля по построенному пути:

``` C++ numberLines
vector<int> path;
int cur = n - 1;
while (cur >= 0) {
    path.push_back(cur);
    cur = prev[cur];
}
```

<em>Вопросы для внимательного читателя:</em>

А теперь поймите, что такой код может уйти в бесконечный цикл. Как надо
проинициализировать массив $prev$, чтобы избежать этого? В каком
порядке будут идти точки в массиве $path$?

<strong>Повторный проход</strong>

Пусть мы уже посчитали массив динамики. Давайте пройдемся от последней
точки к первой и будем по имеющимся значениям состояний определять,
откуда мы пришли.

``` C++ numberLines
vector<int> path;
int cur = n - 1;
while (cur >= 0) {
    path.push_back(cur);
    if (cur >= 1 && dp[cur] == dp[cur - 1] + c[cur]) {
        cur = cur - 1;
    } else if (cur >= 2 && dp[cur] == dp[cur - 2] + c[cur]) {
        cur = cur - 2;
    } else if (cur >= 3 && dp[cur] == dp[cur - 3] + c[cur]) {
        cur = cur - 3;
    }
}
```

Плюс такого подхода в том, что не надо занимать лишнюю память для
хранения предков для каждого состояния.

### За сколько все работает

Значения динамики считаются в данном случае за один проход по массиву,
ответ тоже можно восстановить за один проход, поэтому расход времени и
памяти составит $O(n)$.

---

Теперь мы умеем находить ответ в задачах на ДП, но в некоторых задачах
нам также интересно как мы можем его получить, например в задаче про
черепашку нам может быть интересен путь. Такую задачу называют
восстановлением ответа в динамике.

Есть два способа, которыми можно это сделать.

1\) Хранить в массив prev откуда ты пришел в эту клетку.

Когда мы выбираем максимум из левой и верхней клетки, мы на самом деле
решаем, какой последний ход будет в оптимальном пути до этой клетки -
сверху или слева, и берем ответ для той клетки, сложнный с монетами в
этой клетке. Давайте координаты клетки, откуда мы пришли, хранить в
массиве prev. Или, в данном случае, можно хранить не координаты а
просто 1, если пришли слева, и 0, если пришли сверху.

``` C++ numberLines
for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
        if (i == 0 && j == 0) {
            dp[0][0] = COINS[0][0];
            prev[0][0] = -1;
        }
        else if (i == 0) {
            dp[0][j] = dp[0][j - 1] + COINS[0][j];
            prev[0][j] = 0;
        }
        else if (j == 0) {
            dp[i][0] = dp[i - 1][0] + COINS[i][0];
            prev[i][0] = 1;
        }
        else {
            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + COINS[i][j];
            if (dp[i - 1][j] > dp[i][j - 1]) {
                prev[i][j] = 1;
            }
            else {
                prev[i][j] = 0;
            }
        }
    }
}
```

И, чтобы восстановить ответ, надо просто пройтись с конца по этим
клеткам до самого начала, и развернуть получившуюся
последовательность.

``` C++ numberLines
while (i > 0 || j > 0) {
    if (prev[i][j] == 1) {
        i -= 1;
        answer_directions.push_back("DOWN");
    }
    else {
        j -= 1;
        answer_directions.push_back("RIGHT");
    }
    answer.push_back({i, j});
}
reverse(answer.begin(), answer.end());
reverse(answer_directions.begin(), answer_directions.end());
```

2\) Вместо хранения массива prev догадаться по массиву dp, откуда именно
черепашка пришла в эту клетку.

В данном примере это довольно легко. Если мы уже посчитали весь массив
dp, то теперь можно начиная с конца легко понять, пришла черепашка туда
сверху или слева в оптимальном маршруте - она пришла из клетки с
максимальным числом монет.

``` C++ numberLines
while (i > 0 || j > 0) {
    if (i != 0 && (j == 0 || dp[i - 1][j] > dp[i][j - 1])) {
        i -= 1;
        answer_directions.push_back("DOWN");
    }
    else {
        j -= 1;
        answer_directions.push_back("RIGHT");
    }
    answer.push_back({i, j})
}
reverse(answer.begin(), answer.end());
reverse(answer_directions.begin(), answer_directions.end());
```