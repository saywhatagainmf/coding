# Лекции ФТЛ | Декабрь 2024

###### собирает Кардашевский Илья :)

## День 1 | Дерево отрезков

![Дерево отрезков: просто и быстро / Хабр](https://habrastorage.org/webt/yk/g4/ri/ykg4rio8c3trd8xnxqom8nzyr2o.png)

**Дерево отрезков** — структура данных, которая позволяет эффективно (т.е. за асимптотику **O(log n)**) реализовать операции следующего вида:

1.  нахождение **суммы/минимума/максимума/xor…** элементов массива в заданном отрезке (**a[l…r]** где **l** и **r** поступают на вход алгоритма)
2.  изменение значений как одного так и нескольких элементов (присвоение, прибавление и т. д.)

> <u>Память</u> в дереве отрезков: **4n** («добиваем» до степени двойки 2, и потом удваиваем)

- > здесь и далее _sum_ это тоже самое что _t_

### Построение дерева

```c++
const int maxn = ...;    // максимальное число вершинок
vector<int> a(maxn), t;  // входной массив данных и дерево соответственно

void setup(int n) {
    t.resize(pow(2, log2(n) + 1));
}  // "добиваем" размер массива до степени двойки

// или же
void setup(int n) {
    int m = 1;
    while (m < n) m >>= 1;
    t.resize(m);
}

void build(int v, int tl, int tr) {
    if (tl == tr) {
        t[v] = a[tl];
        return;
    }

    int l = 2 * v, r = 2 * v + 1, tm = (tl + tr) >> 1;

    build(l, tl, tm);
    build(r, tm + 1, tr);

    t[v] = t[l] + t[r];
}

// где то в main ...
for (int i = 0; i < n; i++) cin >> a[i];
build(1, 0, n - 1);  // т.е. запросы все при v = 1, tl = 0, tr = n - 1
```

### Спуск по дереву

```c++
void segment_tree(int v, int tl, int tr, int ql, int qr) {  // O(log n)
    if (ql > qr) return;  // если в процессе отрезок невалдиный
    if (tl == tr) {  // нашли отрезок в вершине v [tl, rt]
        t[v] = a[tl];
    }

    int l = 2 * v, r = 2 * v + 1, tm = (tl + tr) >> 1;

    segment_tree(l, tl, tm, ql, min(tm, qr));  // запрос в левого предка
    segment_tree(r, tm + 1, tr, max(ql, tm + 1),
                 qr);  // запрос в правого предка

    t[v] = t[l] + t[r];
}
```

### Изменение (прибавление) / присвоение в точке

```c++
void update(int v, int tl, int tr, int i, int x) {  // O(log n)
    // sum[4n] -> сумма в каждой вершинки (если длина a уже степень двойки, то
    // 2n)
    if (tl == tr) {
        sum[v] += x;  // sum[v] = x;
        t[v] += x;
        return;
    }

    int l = ..., r = ..., tm = ...;

    if (i <= tm)
        update(v, tl, tm, i, x);
    else
        update(v, tm + 1, tr, i, x);

    sum[v] = sum[l] + sum[r];  // массив сумм в вершинах
}
```

### Найти k-ую единицу

> Логика решения: нам дан массив из 0 и 1, заметим, что если сумма в корне дерева меньше чем k, то k-ой единички нет (возвращаем -1); если сумма в левом родителе больше чем k, то очевидно что единичек там больше чем k, а значит и искомый ответ находится там, иначе ответ в правом родителе (и т. д. рекурсивно находим ответ)

```c++
int find(v, tl, tr, k) {        // O(log n)
    if (sum[v] < k) return -1;  // ->нет k - ой единицы
    if (tl == tr) return tl;

    int l = ..., r = ..., tm = ...;

    if (sum[l] >= k) return find(l, tl, tm, k);
    return find(r, tm + 1, tr, k - sum[l]);
}
```

### Изменение на отрезке

```c++
void update(int v, int tl, int tr, int ql, int qr, int x) {  // O(log n)
    if (ql > qr) return;
    if (ql == tl && qr == tr) {
        sum[v] += x * (tr - tl + 1);  // min[v] += x;
        add[v] += x;
        return;
    }

    int l = ..., r = ..., tm = ...;
    push(v, tl, tr);

    update(l, tl, tm, ql, min(tm, qr), x);
    update(r, tm + 1, tr, max(ql, tm + 1), qr, x);

    sum[v] = sum[l] + sum[r];  // min[v] = min(min[l], min[r])
}

void push(int v, int tl, int tr) {
    int l = 2 * v, r = 2 * v + 1, tm = (tl + tr) >> 1;
    if (add[v] != 0) {
        sum[l] += add[v] * (tm - tl + 1);  // min[l] += add[v];
        sum[r] += add[v] * (tr - tm);      // min[r] += add[v];
        add[l] += add[v];
        add[r] += add[v];
        add[v] = 0;
    }
}
```

### Присвоение на отрезке

```c++
void update(int v, int tl, int tr, int ql, int qr, int x) {  // O(log n)
    if (ql > qr) return;
    if (ql == tl && qr == tr) {
        sum[v] = x * (tr - tl + 1);  // min[v] = x
        tag[v] = ~;  // какой то нейтральный элемент
        return;
    }

    int l = ..., r = ..., tm = ...;
    push(v, tl, tr);

    update(l, tl, tm, ql, min(tm, qr), x);
    update(r, tm + 1, tr, max(ql, tm + 1), qr, x);

    sum[v] = sum[l] + sum[r];  // min[v] = min(min[l], min[r])
}

void push(int v, int tl, int tr) {
    int l = 2 * v, r = 2 * v + 1, tm = (tl + tr) >> 1;
    if (add[v] != ~) {
        sum[l] = tag[v] * (tm - tl + 1);  // min[l] = tag[v];
        sum[r] = tag[v] * (tr - tm);      // min[r] = tag[v];
        tag[l] = tag[v];
        tag[r] = tag[v];
        tag[v] = ~;
    }
}
```

### Присвоение и прибавление на отрезке (одновременно)

|      | `set[v]` | `add[v]` |
| :--: | :------: | :------: |
| _+=_ | (ничего) |   += x   |
| _=_  |    =     |   = 0    |

> (Сначала выполняем запрос присвоения, а потом только прибавления)

```
для push:
if (set[v] != ~) ... // выполняем присваивание
		set[v] = ~;
if (add[v] != 0) ... // выполняем прибавление
```
