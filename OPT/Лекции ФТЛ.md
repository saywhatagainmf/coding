## Лекции ФТЛ | Декабрь 2024

[TOC]

---

## День 1 | Дерево отрезков

![Segment Tree 101 - From Prefix Sum to Segment Tree - DEV Community](https://res.cloudinary.com/practicaldev/image/fetch/s--lYCCoheL--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/7p6g4uo8rz9wrep38xf7.png)

**Дерево отрезков** — структура данных, которая позволяет эффективно (т.е. за асимптотику **O(log n)**) реализовать операции следующего вида:

1.  нахождение **суммы/минимума/максимума/xor…** элементов массива в заданном отрезке (**a[l…r]** где **l** и **r** поступают на вход алгоритма)
2.  изменение значений как одного так и нескольких элементов (присвоение, прибавление и т. д.)

<u>Память</u> в дереве отрезков: **4n** («добиваем» до степени двойки 2, и потом удваиваем, но на самом деле:

$$
t = logn + 1 => n = 2 ^ t
$$

- > здесь и далее _sum_ это тоже самое что _t_ (дерево) (мне просто лень переписывать)

---

### Построение дерева

```c++
const int maxn = ...;    // максимальное число вершинок
vector<int> a(maxn), t;  // входной массив данных и дерево соответственно

void setup(int n) {
    t.resize(pow(2, log2(n) + 1));
}  // "добиваем" размер массива до степени двойки

// или же
void setup(int n) {
    int m = 1;
    while (m < n) m >>= 1;
    t.resize(m);
}

void build(int v, int tl, int tr) {
    if (tl == tr) {
        t[v] = a[tl];
        return;
    }

    int l = 2 * v, r = 2 * v + 1, tm = (tl + tr) >> 1;

    build(l, tl, tm);
    build(r, tm + 1, tr);

    t[v] = t[l] + t[r];
}

// где то в main ...
for (int i = 0; i < n; i++) cin >> a[i];
build(1, 0, n - 1);  // т.е. запросы все при v = 1, tl = 0, tr = n - 1
```

---

### Спуск по дереву

```c++
void st(int v, int tl, int tr, int ql, int qr) {  // O(log n)
    if (ql > qr) return;  // если в процессе отрезок невалдиный
    if (tl == tr) {  // нашли отрезок в вершине v [tl, rt]
        t[v] = a[tl];
    }

    int l = 2 * v, r = 2 * v + 1, tm = (tl + tr) >> 1;

    st(l, tl, tm, ql, min(tm, qr));  // запрос в левого предка
    st(r, tm + 1, tr, max(ql, tm + 1),
             qr);  // в правого

    t[v] = t[l] + t[r];
}
```

---

### Изменение (прибавление) / присвоение в точке

```c++
void update(int v, int tl, int tr, int i, int x) {  // O(log n)
    // sum[4n] -> сумма в каждой вершинки (если длина a уже степень двойки, то
    // 2n)
    if (tl == tr) {
        sum[v] += x;  // sum[v] = x;
        t[v] += x;
        return;
    }

    int l = ..., r = ..., tm = ...;

    if (i <= tm)
        update(v, tl, tm, i, x);
    else
        update(v, tm + 1, tr, i, x);

    sum[v] = sum[l] + sum[r];  // массив сумм в вершинах
}
```

---

### Найти k-ую единицу

> Логика решения: нам дан массив из 0 и 1, заметим, что если сумма в корне дерева меньше чем k, то k-ой единички нет (возвращаем -1); если сумма в левом родителе больше чем k, то очевидно что единичек там больше чем k, а значит и искомый ответ находится там, иначе ответ в правом родителе (и т. д. рекурсивно находим ответ)

```c++
int find(v, tl, tr, k) {        // O(log n)
    if (sum[v] < k) return -1;  // ->нет k - ой единицы
    if (tl == tr) return tl;

    int l = ..., r = ..., tm = ...;

    if (sum[l] >= k) return find(l, tl, tm, k);
    return find(r, tm + 1, tr, k - sum[l]);
}
```

---

### Изменение на отрезке

```c++
void update(int v, int tl, int tr, int ql, int qr, int x) {  // O(log n)
    if (ql > qr) return;
    if (ql == tl && qr == tr) {
        sum[v] += x * (tr - tl + 1);  // min[v] += x;
        add[v] += x;
        return;
    }

    int l = ..., r = ..., tm = ...;
    push(v, tl, tr);

    update(l, tl, tm, ql, min(tm, qr), x);
    update(r, tm + 1, tr, max(ql, tm + 1), qr, x);

    sum[v] = sum[l] + sum[r];  // min[v] = min(min[l], min[r])
}

void push(int v, int tl, int tr) {
    int l = ..., r = ..., tm = ...;
    if (add[v] != 0) {
        sum[l] += add[v] * (tm - tl + 1);  // min[l] += add[v];
        sum[r] += add[v] * (tr - tm);      // min[r] += add[v];
        add[l] += add[v];
        add[r] += add[v];
        add[v] = 0;
    }
}
```

---

### Присвоение на отрезке

```c++
void update(int v, int tl, int tr, int ql, int qr, int x) {  // O(log n)
    if (ql > qr) return;
    if (ql == tl && qr == tr) {
        sum[v] = x * (tr - tl + 1);  // min[v] = x
        tag[v] = ~;  // какой то нейтральный элемент
        return;
    }

    int l = ..., r = ..., tm = ...;
    push(v, tl, tr);

    update(l, tl, tm, ql, min(tm, qr), x);
    update(r, tm + 1, tr, max(ql, tm + 1), qr, x);

    sum[v] = sum[l] + sum[r];  // min[v] = min(min[l], min[r])
}

void push(int v, int tl, int tr) {
    int l = ..., r = ..., tm = ...;
    if (add[v] != ~) {
        sum[l] = tag[v] * (tm - tl + 1);  // min[l] = tag[v];
        sum[r] = tag[v] * (tr - tm);      // min[r] = tag[v];
        tag[l] = tag[v];
        tag[r] = tag[v];
        tag[v] = ~;
    }
}
```

---

### Присвоение и прибавление на отрезке (одновременно)

|      | `set[v]` | `add[v]` |
| :--: | :------: | :------: |
| _+=_ | (ничего) |   += x   |
| _=_  |    =     |   = 0    |

> (Сначала выполняем запрос присвоения, а потом только прибавления)

```
для push:
if (set[v] != ~) ... // выполняем присваивание
		set[v] = ~;
if (add[v] != 0) ... // выполняем прибавление
```

---

## \* Полезное | китайские приколдесы

> (aka. segment tree beats — «дерево отрезков рулит»)

<u>Segment Tree Beats</u> — структура данных, разработанная Ruyi **jiry_2** Ji в 2016 году. Это очень мощный инструмент, идея которого состоит в том, что мы ослабляем условия выхода из рекурсии в дереве отрезков, в результате чего кажется, что алгоритм начинает работать за квадратичное время, но при помощи анализа можно доказать, что на самом деле время работы сильно меньше (**O(n log n)**, **O(n (log n)^2** и т. д.)

### Общая идея

Вернемся к стандартной функции обновления в дереве с массовым обновлением и проталкиванием:

```c++
void update(int v, int tl, int tr, int ql, int qr, int x) {
    if (qr <= l || r <= ql) return;
    if (ql <= l && r <= qr) {
        update_node(...);
        set_push(...);
    }

    push(...);

    int l = ..., r = ..., tm = ...;

    update(l, tl, tm, ql, qr, x);
    update(r, tm, tr, ql, qr, x);

    recalc(...);
}
```

> Этот код будет работать за **O(log n)**

> <u>Идея STB</u>: пускай запросы изменения таковы, что мы не всегда можем пересчитать значение на отрезке при условии выполнения **tag_condition**, тогда давайте усилим условие **break_condition** и ослабим условие **tag_condition**, чтобы теперь мы могли уже пересчитать значение в вершине, не запускаясь рекурсивно, но при этом асимптотика не стала квадратичной.

```c++
void update(int v, int tl, int tr, int ql, int qr, int x) {
    if (break_condition(v, ql, qr, x)) return;
    if (tag_condition(v, ql, qr, x)) {
        update_node(...);
        set_push(...);
        return;
    }

    push(...);

    int l = ..., r = ..., tm = ...;

    update(l, tl, tm, ql, qr, x);
    update(r, tm, tr, ql, qr, x);

    recalc();
}
```

Иными словами, все, что нам нужно сделать — это придумать наиболее сильное условие break_condition, при котором в текущем поддереве запрос изменения точно ничего не изменит, а также наиболее сильное условие tag_condition, при котором можно будет обновлять значение в текущей вершине, не запускаясь рекурсивно из детей.

```
break_conditinon = (qr <= tl || r <= ql || ...)
tag_condition 	 	 = (ql <= l && r <= qr && ...)
```

---

## День 2 | Графы (кратчайшие пути, мин. остовы, снм)

![Алгоритм Дейкстры - Алгоритмика](https://ru.algorithmica.org/cs/shortest-paths/img/dijkstra.gif)

---

### BFS (_англ._ _breadth-first search_)

> Дан граф, веса ребер которого равны 1. Требуется найти путь минимального веса от варшины s до вершины t.

<u>Реализация</u>:

```c++
vector<int> g[maxn];

void bfs(int s) {
    queue<int> q;
    q.push(s);

    vector<int> d(n, -1), p(n);
    d[s] = 0;

    while (!q.empty()) {
        int v = q.front();
        q.pop();
        for (int u : g[v]) {
            if (d[u] == -1) {
                q.push(u);
                d[u] = d[v] + 1;
                p[u] = v;
            }
        }
    }
}
```

<u>Восстановление пути</u>:

```c++
while (v != s) {
    cout << v << endl;
    v = p[v];
}
```

#### 0-1 BFS

Если веса некоторых ребер могут быть нулевыми, то кратчайшие пути искать не сильно сложнее.

> <u>Ключевое наблюдение</u>: если от вершины _a_ до вершины _b_ можно дойти по пути, состоящему из нулевых рёбер, то кратчайшие расстояния от вершины _s_ до этих вершин совпадают.

Если в нашем графе оставить только 0-рёбра, то он распадётся на компоненты связности, в каждой из которых ответ одинаковый. Если теперь вернуть единичные рёбра и сказать, что эти рёбра соединяют не вершины, а компоненты связности, то мы сведём задачу к обычному BFS.

Получается, запустив обход, мы можем при обработке вершины _v_, у которой есть нулевые ребра в непосещенные вершины, сразу пройтись по ним и добавить все вершины нулевой компоненты, проставив им такое же расстояние, как и у _v_.

Это можно сделать и напрямую, запустив BFS внутри BFS, однако можно заметить, что достаточно при посещении вершины просто добавлять всех её непосещенных соседей по нулевым ребрам в _голову_ очереди, чтобы обработать их раньше, чем те, которые там уже есть. Это легко сделать, если очередь заменить деком

<u>Реализация</u>:

```c++
vector<int> d(n, -1);
d[s] = 0;

deque<int> q;
q.push_back(s);

while (!q.empty()) {
    int v = q.front();
    q.pop_front();
    for (auto [u, w] : g[v]) {
        if (d[u] == -1) {
            d[u] = d[v] + w;
            if (w == 0)
                q.push_front(u);
            else
                q.push_back(u);
        }
    }
}
```

#### 1-k BFS

Теперь веса рёбер принимают значения от 1 до некоторого небольшого _k_, и всё так же требуется найти кратчайшие расстояния от вершины _s_, но уже в плане суммарного веса.

> _<u>Наблюдение</u>:_ максимальное кратчайшее расстояние в графе равно (n - 1) \* k.

Заведём для каждого расстояния _d_ очередь _q_(d), в которой будут храниться вершины, находящиеся на расстоянии _d_ от _s_ — плюс, возможно, некоторые вершины, до которых мы уже нашли путь длины _d_ от _s_, но для которых возможно существует более короткий путь. Нам потребуется **O((n−1)⋅k)** очередей.

Положим изначально вершину _s_ в _q_(0), а дальше будем брать вершину из наименьшего непустого списка и класть всех её непосещенных соседей в очередь с номером _d_(v) + _w_ и релаксировать _d_(u), не забывая при этом, что кратчайшее расстояние до неё на самом деле может быть и меньше.

<u>Реализация</u>:

```c++
int d[maxn];
d[s] = 0;

queue<int> q[maxd];
q[0].push_back(s);

for (int dist = 0; dist < maxd; dist++) {
    while (!q[dist].empty()) {
        int v = q[dist].front();
        q[dist].pop();
        if (d[v] > dist) continue;
        for (auto [u, w] : g[v]) {
            if (d[u] < d[v] + w) {
                d[u] = d[v] + w;
                q[d[u]].push(u);
            }
        }
    }
}
```

---

### Алгоритм Флойда-Уоршелла

— алгоритм нахождения длин кратчайших путей между всеми парами вершин во взвешенном ориентированном графе. Работает корректно, если в графе нет циклов отрицательной величины, а в случае, когда такой цикл есть, позволяет найти хотя бы один такой цикл. <u>Асимптотика</u>: **O(n^3)**.

<u>Реализация</u>:

```c++
void floyd(int s, int f) {
    // d[v][u] = d[u][v] = inf; (если нет ребра)
  	// d[v][u] = d[u][v] = w[u][v] = w[v][u]
    // d[v][v] = d[u][u] = 0;
    for (int mid = 1; mid <= n; mid++) {
        for (int v = 1; v <= n; v++) {
            for (int u = 1; u <= n; u++) {
                relax(d[v][u], d[v][mid] + d[mid][u]);
            }
        }
    }
    cout << d[s][f] << '\n';
}
```

---

### Алгоритм Форда-Беллмана

> Для заданного взвешенного графа _G = (V, E)_ найти кратчайшие пути из заданной вершины _s_ до всех остальных вершин. В случае, когда в графе _G_ содержатся циклы с отрицательным суммарным весом, достижимые из _s_, сообщить, что кратчайших путей не существует.

<u>Псевдокод</u>:

```c++
int fordbellman(int s, int f) {
    for (v in V) d[v] = 1;
    d[s] = 0;

    for (i = 0..n - 1) {
        for ((u, v)in E) {
            relax(d[v], d[u] + w[u][v]);
        }
    }
    return d[f];
}
```

---

### SPFA (shortest path faster algorithm)

— это усовершенствованный алгоритм Беллмана-Форда, часто применяющийся на соревнованиях по спортивному программированию. Он вычисляет кратчайшие пути от стартовой вершины до всех остальных во взвешенном ориентированном графе.

<u>Псевдокод</u>:

```c++
void spfa(int s) {
    for (v in V) d[v] = inf;
    d[s] = 0;

    q.push(s);
    while (!q.empty()) {
        u = q.pop();
        for ((u, v)in E) {
            if (d[u] + w[u][v] < d[v]) {
                d[v] = d[u] + w[u][v];
                if (v not in q) {
                    q.push(v);
                }
            }
        }
    }
}
```

---

### Алгоритм Дейкстры

> Заведём массив _d_, в котором для каждой вершины _v_ будем хранить текущую длину _d_(v) кратчайшего пути из _s_ в _v_. Изначально _d_(s) = 0, а для всех остальных вершин расстояние равно бесконечности (или любому числу, которое заведомо больше максимально возможного расстояния).
>
> Во время работы алгоритма мы будем постепенно обновлять этот массив, находя более оптимальные пути к вершинам и уменьшая расстояние до них. Когда мы узнаем, что найденный путь до какой-то вершины _v_ оптимальный, мы будем помечать эту вершину, поставив единицу (_a_(v) = 1) в специальном массиве _a_, изначально заполненном нулями.
>
> Сам алгоритм состоит из _n_ итераций, на каждой из которых выбирается вершина _v_ с наименьшей величиной _d_(v) среди ещё не помеченных.
>
> **Заметим, что на первой итерации выбрана будет стартовая вершина _s_.**
>
> Выбранная вершина отмечается в массиве _a_, после чего из из вершины _v_ производятся _релаксации_: просматриваем все исходящие рёбра (_v_,_u_) и для каждой такой вершины _u_ пытаемся улучшить значение _d_(u), выполнив присвоение:
>
> $$
> d(u) = min(d(v), d(v) + w), w = weight(v, u)
> $$

<u>Реализация для «плотных» графов</u> (**m ~ n^2**):

```c++
const int maxn = 1e5, inf = 1e9;
vector<pair<int, int> > g[maxn];
int n;

vector<int> dijkstra(int s) {
    vector<int> d(n, inf), a(n, 0);
    d[s] = 0;
    for (int i = 0; i < n; i++) {
        // находим вершину с минимальным d[v] из ещё не помеченных
        int v = -1;
        for (int u = 0; u < n; u++)
            if (!a[u] && (v == -1 || d[u] < d[v])) v = u;
        // помечаем её и проводим релаксации вдоль всех исходящих ребер
        a[v] = true;
        for (auto [u, w] : g[v]) d[u] = min(d[u], d[v] + w);
    }
    return d;
}
```

<u>Реализация для «разреженых» графов</u> (**m ~ n**):

```c++
vector<int> dijkstra(int s) {
    vector<int> d(n, inf);
    d[root] = 0;
    set<pair<int, int> > q;
    q.insert({0, s});
    while (!q.empty()) {
        int v = q.begin()->second;
        q.erase(q.begin());
        for (auto [u, w] : g[v]) {
            if (d[u] > d[v] + w) {
                q.erase({d[u], u});
                d[u] = d[v] + w;
                q.insert({d[u], u});
            }
        }
    }
    return d;
}
```

---

### Минимальный остов

![Снимок экрана 2023-12-21 в 10.54.36](/Users/ikard/Downloads/Снимок экрана 2023-12-21 в 10.54.36.png)

— дерево минимального веса, которое является подграфом данного неориентированного графа. Такие деревья называют <u>_остовами_</u>. По-английски — **_minimum spanning tree_** (дословно, минимальное покрывающее дерево, **MST**).

Почему дерево? Потому что в противном случае там был бы цикл, из которого можно удалить какое-то ребро и получить более оптималный ответ. А если это больше, чем одно дерево, то какие-то две вершины остаются несвязны.

#### Лемма о безопасном ребре

Назовем подграф графа «_безопасным_», если оно является подграфом какого-то <u>минимального остова</u>.

Назовем ребро «_безопасным_», если при добавлении его в подграф получившийся подграф тоже является безопасным, то есть подграфом какого-то <u>минимального остова</u>.

Все алгоритмы для поиска минимального остова опираются на следующее утверждение:

> **Лемма о безопасном ребре.** Рассмотрим произвольный разрез (удалили некоторые рёбра так, что граф распался на две части) какого-то подграфа минимального остова. Тогда ребро минимального веса, пересекающее этот разрез (то есть соединяющее их при добавлении) является безопасным.

> **Доказательство:** Рассмотрим какой-то минимальный остов, в котором этого ребра нет. Если его добавить, то образуется цикл, из которого можно выкинуть ребро не меньшего веса, получив ответ точно не хуже.

Получается, что мы можем действовать жадно — на каждом шаге добавлять ребро минимального веса, которое увеличивает наш остов

#### Алгоритм Прима

Один из подходов — строить минимальный остов постепенно, добавляя в него рёбра по одному.

- Изначально остов — одна произвольная вершина.
- Пока минимальный остов не найден, выбирается ребро минимального веса, исходящее из какой-нибудь вершины текущего остова в вершину, которую мы ещё не добавили. Добавляем это ребро в остов и начинаем заново, пока остов не будет найден.

Этот алгоритм очень похож на алгоритм Дейкстры, только тут мы выбираем следующую вершину с другой весовой функцией — вес соединяющего ребра вместо суммарного расстояния до неё.

<u>Реализация</u> (для плотных графов):

```c++
// O(n ^ 2)

const int maxn =.., inf =..;

bool used[maxn];
vector<pair<int, int>> g[maxn];

int min_edge[maxn] = {inf}, best_edge[maxn];
min_edge[0] = 0;

// ...

for (int i = 0; i < n; i++) {
    int v = -1;
    for (int u = 0; u < n; j++)
        if (!used[u] && (v == -1 || min_edge[u] < min_edge[v])) v = u;

    used[v] = 1;
    if (v != 0) cout << v << " " << best_edge[v] << '\n';

    for (auto e : g[v]) {
        int u = e.first, w = e.second;
        if (w < min_edge[u]) {
            min_edge[u] = w;
            best_edge[u] = v;
        }
    }
}
```

<u>Реализация</u> (линейный поиск оптимальной вершины меняется на аналогичный Дейкстре):

```c++
// O(m log n)

set<pair<int, int> > q;
int d[maxn];

while (q.size()) {
    v = q.begin()->second;
    q.erase(q.begin());

    for (auto e : g[v]) {
        int u = e.first, w = e.second;
        if (w < d[u]) {
            q.erase({d[u], u});
            d[u] = w;
            q.insert({d[u], u});
        }
    }
}
```

#### Алгоритм Борувки

Переформулируем лемму о безопасном ребре в частном случае:

> **Лемма.** Для любой вершины минимальное инцидентное ей реборо является безопасным.

> **Доказательство.** Пусть есть минимальный остов, в котором для какой-то вершины _v_ нет её минимального инцидентного ребра. Тогда, если добавить это ребро, образуется цикл, из которого можно удалить другое ребро, тоже инцидентное _v_, но имеющее не меньший вес.

Алгоритм Борувки опирается на этот факт и заключается в следующем:

1.  Для каждой вершины найдем минимальное инцидентное ей ребро.
2.  Добавим все такие рёбра в остов (это безопасно — см. лемму) и сожмем получившиеся компоненты, то есть объединим списки смежности вершин, которые эти рёбра соединяют.
3.  Повторяем шаги 1-2, пока в графе не останется только одна вершина-компонента.

Алгоритм может работать неправильно, если в графе есть ребра, равные по весу. Пример: «треугольник» с одинаковыми весами рёбер. Избежать такую ситуацию можно, введя какой-то дополнительный порядок на рёбрах — например, сравнивая пары из веса и номера ребра.

<u>Псевдокод</u>:

```c++
// G — исходный граф
// w — весовая функция
function boruvka():
    while T.size < n − 1
        for k ∈ Component     // Component — множество компонент связности в T. Для
            w(minEdge[k]) = ∞ // каждой компоненты связности вес минимального ребра = ∞.
        findComp(T)           // Разбиваем граф T на компоненты связности обычным dfs-ом.
        for (u, v) ∈ E
            if u.comp ≠ v.comp
                if w(minEdge[u.comp]) > w(u, v)
                    minEdge[u.comp] = (u, v)
                if w(minEdge[v.comp]) > w(u, v)
                    minEdge[v.comp] = (u, v)
        for k ∈ Component
            T.addEdge(minEdge[k]) // Добавляем ребро, если его не было в T
    return T

```

---

### Система непересекающихся множеств

![Снимок экрана 2023-12-21 в 11.32.57](/Users/ikard/Downloads/Снимок экрана 2023-12-21 в 11.32.57.png)

Система непересекающихся множеств (_англ. disjoint set union_) — структура данных, позволяющая объединять непересекающиеся множества и отвечать на разные запросы про них, например:

- _Находятся ли элементы a и b в одном множестве?_
- _Чему равен размер данного множества?_

Более формально, изначально имеется _n_ элементов, каждый из которых находится в отдельном (своём собственном) множестве. Структура поддерживает две базовые операции:

- Объединить два каких-либо множества
- Запросить, в каком множестве сейчас находится указанный элемент

Обе операции выполняются в среднем **_почти_** за O(1) (<u>но не совсем</u>)

#### Инициализация

```c++
const int maxn = ..;
int p[maxn];

for (int i = 0; i < n; i++) p[i] = i;
```

#### Поиск корня

```c++
int get(int v) { return (v == root[v]) ? v : get(p[v]); }
```

#### Принадлежность множеству

```c++
int leader(int v) {
    if (p[v] == v) return v;
    return leader(p[v]);
}
```

#### Объединение двух множеств

```c++
void unite(int a, int b) {
    a = leader(a), b = leader(b);
    p[a] = b;
}
```

#### Эвристики

> ##### Оптимизация (1)
>
> ```c++
> int leader(int v) { return (p[v] == v) ? v : p[v] = leader(p[v]); }
> ```
>
> ##### Оптимизации (2)
>
> ```c++
> // Ранговая эвристика
> // h(v) - высота поддерева у вершины v
> void unite(int a, int b) {
>     a = leader(a), b = leader(b);
>     if (h[a] > h[b])
>         swap(a, b);
>     h[b] = max(h[b], h[a] + 1);
>     p[a] = b;
> }
>
> // Весовая эвристика
> // s(v) - размер поддерева у вершины v
> void unite(int a, int b) {
>     a = leader(a), b = leader(b);
>     if (s[a] > s[b])
>         swap(a, b);
>     s[b] += s[a];
>     p[a] = b;
> }
> ```

Эвристика сжатия путей улучшает асимптотику до **_O_(log _n_)** в среднем. Здесь используется именно амортизированная оценка — понятно, что в худшем случае нужно будет сжимать весь бамбук за **_O_(_n_)**.

Индукцией несложно показать, что весовая и ранговая эвристики ограничивают высоту дерева до **_O_(log _n_)**, а соответственно и асимптотику нахождения корня тоже.

#### Итоговая реализация

```c++
int p[maxn], s[maxn];

int leader(int v) { return (p[v] == v) ? v : p[v] = leader(p[v]); }

void unite(int a, int b) {
    a = leader(a), b = leader(b);
    if (s[a] > s[b]) swap(a, b);
    s[b] += s[a];
    p[a] = b;
}

void init(n) {
    for (int i = 0; i < n; i++) p[i] = i, s[i] = 1;
}
```

---

### Алгоритм Крускала

Так же, как и в простой версии алгоритма Крускала, отсортируем все рёбра по неубыванию веса.

Затем поместим каждую вершину в своё дерево (т.е. своё множество) — на это уйдёт в сумме **O(n)**. Перебираем все рёбра (в порядке сортировки) и для каждого ребра за O (1) определяем, принадлежат ли его концы разным деревьям.

Наконец, объединение двух деревьев будет осуществляться вызовом union - также за O(1).

Итого мы получаем асимптотику O (M log N + N + M) = O (M log N).

<u>Реализация</u>:

```c++
const int maxn = ..;
int p[maxn];

int leader(int v) { return (p[v] == v) ? v : p[v] = leader(p[v]); }

void unite(int a, int b) {
    a = leader(a);
    b = leader(b);
    if (rand() & 1) swap(a, b);
    if (a != b) p[a] = b;
}

// ... в функции main(): ...

int m;
vector<pair<int, pair<int, int>>> g;  // вес - вершина 1 - вершина 2
// ... чтение графа...

int cost = 0;
vector<pair<int, int>> res;

sort(g.begin(), g.end());

for (int i = 0; i < n; ++i) p[i] = i;
for (int i = 0; i < m; ++i) {
    int a = g[i].second.first, b = g[i].second.second, l = g[i].first;
    if (leader(a) != leader(b)) {
        cost += l;
        res.push_back(g[i].second);
        unite(a, b);
    }
}
```
